trigger: none
pool:
  vmImage: 'windows-latest'

variables:
  azureDevOpsOrg: "chand1502877"
  azureDevOpsProject: "DevOps_pro1"
  pipelineIds: "4"

stages:
- stage: UpdateReleasePipeline
  displayName: 'Update Classic Release Pipeline'
  jobs:
  - job: UpdatePipeline
    displayName: 'Add PROD Stage to Classic Release Pipelines'
    steps:
    - task: PowerShell@2
      displayName: 'Modify Classic Release Pipeline'
      inputs:
        targetType: 'inline'
        script: |
          $Org = "$(azureDevOpsOrg)"
          $Project = "$(azureDevOpsProject)"
          $Pat = "AMNGntv1LLRpLKlNL82zFDouDPYm5fu6fsFzl3GC0jTx80cHNMqQJQQJ99BBACAAAAAMVcP5AAASAZDO1Dur"
          $ApiVersion = "7.1-preview.4"
          $PipelineIds = "$(pipelineIds)" -split "," | ForEach-Object { [int]$_.Trim() }

          $AuthHeader = "Basic " + [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(":$Pat"))
          $Headers = @{
              "Authorization" = $AuthHeader
              "Content-Type" = "application/json"
              "Accept" = "application/json; api-version=$ApiVersion"
          }

          Function Add-ProdStage {
              param ([int]$PipelineId)

              Write-Host "üöÄ Processing Pipeline ID: $PipelineId"

              $url = "https://vsrm.dev.azure.com/$Org/$Project/_apis/release/definitions/$($PipelineId)?api-version=$ApiVersion"
              try {
                  $response = Invoke-RestMethod -Uri $url -Headers $Headers -Method Get
                  $pipeline = $response | ConvertTo-Json -Depth 20 | ConvertFrom-Json
                  Write-Host "‚úÖ Successfully fetched pipeline ID: $PipelineId"
              } catch {
                  Write-Host "‚ùå ERROR: Failed to fetch pipeline ID: $PipelineId"
                  Write-Host "üî¥ API Response: $_"
                  return
              }

              Write-Host "üîç Available Stages in Pipeline ${PipelineId}:"
              $pipeline.environments | ForEach-Object { Write-Host "Stage: $($_.name) (ID: $($_.id))" }

              $preProdStage = $pipeline.environments | Where-Object { $_.name -eq 'pre-prod' } | Select-Object -First 1
              if ($null -eq $preProdStage) {
                  Write-Host "‚ö†Ô∏è No pre-prod stage found in pipeline $PipelineId"
                  return
              }

              Write-Host "‚úÖ Found pre-prod stage in pipeline $PipelineId (ID: $($preProdStage.id))"

              if ($pipeline.environments.name -contains 'prod') {
                  Write-Host "‚ö†Ô∏è PROD stage already exists in pipeline $PipelineId"
                  return
              }

              # Reassign rank to existing stages
              for ($i = 0; $i -lt $pipeline.environments.Count; $i++) {
                  $pipeline.environments[$i].rank = $i + 1
              }

              $newRank = $pipeline.environments.Count + 1

              # Do not manually set 'id' for the new 'prod' stage
              $prodStage = @{
                  name = "prod"
                  rank = $newRank
                  owner = @{
                      id = $pipeline.createdBy.id
                      displayName = $pipeline.createdBy.displayName
                  }
                  variables = @{}
                  variableGroups = @()
                  preDeployApprovals = @{
                      approvals = @(
                          @{
                              rank = 1
                              isAutomated = $false
                              isNotificationOn = $false
                              approver = @{ 
                                  id = "7a7ba7bf-0a4e-625b-b1fb-8dd3e8dcb937"
                                  displayName = "Krishna Sri Ram"
                              }
                          }
                      )
                      approvalOptions = @{
                          requiredApproverCount = 1
                          releaseCreatorCanBeApprover = $true
                          autoTriggeredAndPreviousEnvironmentApprovedCanBeSkipped = $false
                          enforceIdentityRevalidation = $false
                          timeoutInMinutes = 43200
                      }
                  }
                  postDeployApprovals = @{
                      approvals = @(
                          @{
                              rank = 1
                              isAutomated = $true
                              isNotificationOn = $false
                              approver = @{
                                  id = "00000000-0000-0000-0000-000000000000"
                                  displayName = "Automatic"
                              }
                          }
                      )
                      approvalOptions = @{
                          requiredApproverCount = 0
                          releaseCreatorCanBeApprover = $false
                          autoTriggeredAndPreviousEnvironmentApprovedCanBeSkipped = $false
                          enforceIdentityRevalidation = $false
                          timeoutInMinutes = 43200
                      }
                  }
                  deployPhases = @(
                      @{
                          name = "Run on agent"
                          rank = 1
                          phaseType = "agentBasedDeployment"
                          workflowTasks = @()
                      }
                  )
                  conditions = @(
                      @{
                          conditionType = "environmentState"
                          name = "pre-prod"  # Fixed the condition to depend on pre-prod
                          value = "succeeded"
                      }
                  )
                  environmentOptions = @{
                      emailNotificationType = "OnlyOnFailure"
                      emailRecipients = "release.environment.owner;release.creator"
                      skipArtifactsDownload = $false
                      timeoutInMinutes = 0
                      enableAccessToken = $false
                      publishDeploymentStatus = $true
                      badgeEnabled = $false
                      autoLinkWorkItems = $false
                  }
                  retentionPolicy = @{
                      daysToKeep = 30
                      releasesToKeep = 3
                      retainBuild = $true
                  }
              }

              # Remove manually setting 'id' for the prodStage
              $prodStage = $prodStage | ConvertTo-Json -Depth 10 | ConvertFrom-Json

              # Add the 'prod' stage to the pipeline environments
              $pipeline.environments += $prodStage

              # Reassign rank order for all stages
              for ($i = 0; $i -lt $pipeline.environments.Count; $i++) {
                  $pipeline.environments[$i].rank = $i + 1
              }

              $updateUrl = "https://vsrm.dev.azure.com/$Org/$Project/_apis/release/definitions/$($PipelineId)?api-version=$ApiVersion"
              $jsonBody = $pipeline | ConvertTo-Json -Depth 15 -Compress

              try {
                  $response = Invoke-RestMethod -Uri $updateUrl -Headers $Headers -Method Put -Body $jsonBody
                  Write-Host "‚úÖ Successfully added PROD stage to Pipeline $PipelineId"
                  Write-Host "üîπ Final Stage Order:"
                  $response.environments | ForEach-Object { Write-Host "$($_.rank). $($_.name) (ID: $($_.id))" }
              } catch {
                  Write-Host "‚ùå ERROR: Failed to update pipeline ID: $PipelineId"
                  Write-Host "üî¥ Error Details: $($_.Exception.Message)"
                  if ($_.Exception.Response) {
                      $reader = New-Object System.IO.StreamReader($_.Exception.Response.GetResponseStream())
                      $reader.BaseStream.Position = 0
                      $reader.DiscardBufferedData()
                      $responseBody = $reader.ReadToEnd()
                      Write-Host "üî¥ Full API Response: $responseBody"
                  }
              }
          }

          foreach ($PipelineId in $PipelineIds) {
              Add-ProdStage -PipelineId $PipelineId
          }
