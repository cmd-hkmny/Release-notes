# Get Work Item Details
        function Get-WorkItemDetails {
            param($id)
            if (-not $id) {
                Write-Warning "Skipped work item with null ID"
                return $null
            }
            $uri = "$orgUrl/$PROJECT_NAME/_apis/wit/workitems/${id}?`$expand=relations&api-version=$WIT_API_VERSION"
            try {
                $result = Invoke-RestMethod -Uri $uri -Headers $authHeader -ErrorAction SilentlyContinue
                if ($result) {
                    return [PSCustomObject]@{
                        Id = $result.id
                        Title = $result.fields.'System.Title'
                        Type = $result.fields.'System.WorkItemType'
                        Url = "$orgUrl/$PROJECT_NAME/_workitems/edit/$($result.id)"
                        Relations = $result.relations
                    }
                }
            } catch {
                Write-Warning "Failed to fetch work item ${id}: $_"
            }
            return $null
        }
        # Collect work items
        $allWorkItems = @{}
        $childWorkItems = @()
        $workItemsInPRs = @()

        foreach ($pr in $filteredPRs) {
            $workItems = Invoke-RestMethod -Uri "$orgUrl/$PROJECT_NAME/_apis/git/repositories/$REPO_NAME/pullRequests/$($pr.pullRequestId)/workitems?api-version=$GIT_API_VERSION" -Headers $authHeader
            foreach ($item in $workItems.value) {
                $wi = Get-WorkItemDetails -id $item.id
                if ($wi -and $wi.Type -in @('Product Backlog Item', 'Bug', 'Feature', 'Task', 'Issue', 'User Story', 'Epic')) {
                    if (-not $allWorkItems.ContainsKey($wi.Id)) {
                        $allWorkItems[$wi.Id] = $wi
                        $childWorkItems += $wi
                    }
                    $workItemsInPRs += $wi.Id
                }
            }
        }

        # Build hierarchy without duplicates but ensure all work items are shown
        $hierarchyMap = @{}
        $processedItems = @{}
        $flatWorkItems = @{}

        function Get-FullHierarchy {
            param($item)
            $hierarchy = @()
            $current = $item
            
            # Walk up the hierarchy
            while ($current) {
                $hierarchy += $current
                $parentRel = $current.Relations | Where-Object { $_.rel -eq "System.LinkTypes.Hierarchy-Reverse" } | Select-Object -First 1
                if (-not $parentRel) { break }
                
                $parentId = $parentRel.url -split '/' | Select-Object -Last 1
                if (-not $allWorkItems.ContainsKey($parentId)) {
                    $parent = Get-WorkItemDetails -id $parentId
                    if ($parent) {
                        $allWorkItems[$parentId] = $parent
                    } else {
                        break
                    }
                }
                $current = $allWorkItems[$parentId]
            }
            
            [Array]::Reverse($hierarchy)
            return $hierarchy
        }

        # First show all work items in a flat list
        $mdContent = "# Release Notes for $REPO_NAME`n`n"
        $mdContent += "**Release Range**: $previousTag to $latestTag`n"
        $mdContent += "**Date**: $(Get-Date -Format 'yyyy-MM-dd')`n"
        $mdContent += "**Commits Included**: $commitCount`n"
        $mdContent += "**Pull Requests Merged**: $prCount`n"
        $mdContent += "**Work Items Completed**: $($childWorkItems.Count)`n`n"

        if ($childWorkItems.Count -gt 0) {
            $mdContent += "## Work Items Hierarchy`n"
            
            $completeHierarchies = @()
            foreach ($item in $childWorkItems) {
                $hierarchy = Get-FullHierarchy -item $item
                $completeHierarchies += ,$hierarchy
            }

            $processedItems = @{}
            $currentEpic = $null
            
            foreach ($hierarchy in $completeHierarchies) {
                $epic = $hierarchy | Where-Object { $_.Type -eq "Epic" } | Select-Object -First 1
                
                # Add spacing between different epics
                if ($currentEpic -and $currentEpic.Id -ne $epic.Id) {
                    $mdContent += "`n"
                }
                $currentEpic = $epic
                
                for ($i = 0; $i -lt $hierarchy.Count; $i++) {
                    $item = $hierarchy[$i]
                    if (-not $processedItems.ContainsKey($item.Id)) {
                        $indent = "    " * $i
                        $icon = switch ($item.Type) {
                            "Epic" { "üè∞" }
                            "Feature" { "üß©" }
                            default { "üîß" }
                        }
                        
                        $mdContent += "$indent* $icon **$($item.Type) #$($item.Id)**: [$($item.Title)]($($item.Url))`n"
                        $processedItems[$item.Id] = $true
                    }
                }
            }
        }
        if ($prCount -gt 0) {
            $mdContent += "## Pull Requests`n"
            $mdContent += ($filteredPRs | Sort-Object -Property pullRequestId | ForEach-Object {
                $prDate = [datetime]::Parse($_.creationDate)
                "* **PR #$($_.pullRequestId)**: [$($_.title)]($orgUrl/$PROJECT_NAME/_git/$REPO_NAME/pullrequest/$($_.pullRequestId)) (Created by $($_.createdBy.displayName) on $($prDate.ToString('yyyy-MM-dd')))"
            }) -join "`n"
            $mdContent += "`n`n"
        }

        $mdContent += "[[_Back to Releases|Home]]`n"

        $artifactFilePath = "$ARTIFACT_DIR/$REPO_NAME-$latestTag.md"
        $mdContent | Out-File -FilePath $artifactFilePath -Encoding utf8

        Write-Host "##vso[task.setvariable variable=RELEASE_NOTES_CONTENT]$mdContent"
        Write-Host "##vso[task.setvariable variable=RELEASE_NOTES_FILE]$artifactFilePath"
        Write-Host "##vso[task.setvariable variable=RELEASE_NOTES_PATH]$WIKI_FOLDER/$REPO_NAME-$latestTag"
=====================================================================================================================================
$healthCheckTask = @{
    taskId      = "e213ff0f-5d5c-4791-802d-52ea3e7be1f1"  # PowerShell@2
    version     = "2.*"
    name        = "HealthCheckAndRollback"
    enabled     = $true
    inputs      = @{
        targetType  = "inline"
        script      = @'
# Enable TLS 1.2
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

# Configuration
$configFile = "$(ConfigFilePath)"  # Path to JSON config file passed as pipeline variable
$timeoutSeconds = 15
$idleTimeoutMs = 60000  # 60 seconds in milliseconds

# Initialize counters
$global:overallSuccess = $true
$global:anyRollbackAttempted = $false

# Load configuration from JSON file
try {
    $config = Get-Content -Path $configFile -Raw | ConvertFrom-Json
    Write-Host "Loaded configuration for $($config.applications.Count) applications"
    
    # Validate configuration
    if (-not $config.applications -or $config.applications.Count -eq 0) {
        throw "No applications configured in JSON file"
    }
}
catch {
    Write-Host "##vso[task.logissue type=error]Failed to load configuration: $($_.Exception.Message)"
    exit 1
}

function Invoke-HealthCheck {
    param (
        [string]$server,
        [string]$healthCheckUrl,
        [System.Management.Automation.PSCredential]$cred
    )
    
    try {
        Write-Host "`n=== Health Check on $server ($healthCheckUrl) ==="
        
        $sessionParams = @{
            ComputerName = $server
            Credential = $cred
            SessionOption = New-PSSessionOption -IdleTimeout $idleTimeoutMs
            ErrorAction = 'Stop'
        }
        $session = New-PSSession @sessionParams
        
        try {
            $null = Invoke-Command -Session $session -ScriptBlock { $true } -ErrorAction Stop
            
            $response = Invoke-Command -Session $session -ScriptBlock {
                param($url, $timeout)
                try {
                    Invoke-WebRequest -Uri $url -UseBasicParsing -TimeoutSec $timeout
                }
                catch {
                    @{
                        StatusCode = 500
                        StatusDescription = $_.Exception.Message
                    }
                }
            } -ArgumentList $healthCheckUrl, $timeoutSeconds
            
            if ($response.StatusCode -eq 200) {
                Write-Host "[SUCCESS] Health check passed on $server"
                return $true
            }
            else {
                Write-Host "[FAILURE] Health check failed on $server (Status: $($response.StatusCode))"
                Write-Host "Response: $($response.StatusDescription)"
                return $false
            }
        }
        catch {
            Write-Host "[ERROR] Health check execution failed on $server"
            Write-Host "Details: $($_.Exception.Message)"
            return $false
        }
        finally {
            if ($session) { Remove-PSSession $session -ErrorAction SilentlyContinue }
        }
    }
    catch {
        Write-Host "[ERROR] Connection failed to $server"
        Write-Host "Details: $($_.Exception.Message)"
        return $false
    }
}

function Invoke-Rollback {
    param (
        [string]$server,
        [string]$deploymentRoot,
        [string]$webApplicationName,
        [System.Management.Automation.PSCredential]$cred
    )
    
    try {
        Write-Host "`n=== Attempting Rollback on $server ==="
        Write-Host "Application: $webApplicationName"
        Write-Host "Deployment Root: $deploymentRoot"
        
        $sessionParams = @{
            ComputerName = $server
            Credential = $cred
            SessionOption = New-PSSessionOption -IdleTimeout $idleTimeoutMs
            ErrorAction = 'Stop'
        }
        $session = New-PSSession @sessionParams
        
        try {
            # Verify deployment root exists
            $deploymentRootExists = Invoke-Command -Session $session -ScriptBlock {
                param($deploymentRoot)
                Test-Path $deploymentRoot
            } -ArgumentList $deploymentRoot

            if (-not $deploymentRootExists) {
                Write-Host "[ERROR] Deployment root path does not exist: $deploymentRoot"
                return $false
            }

            # Get available deployment folders
            $folders = Invoke-Command -Session $session -ScriptBlock {
                param($deploymentRoot)
                Get-ChildItem -Path $deploymentRoot -Directory |
                    Where-Object { $_.Name -match "^\d+(\.\d+)*_\d{8}\.\d{6}$" } |
                    Sort-Object {
                        $timestamp = $_.Name.Split("_")[1]
                        [datetime]::ParseExact($timestamp, "ddMMyyyy.HHmmss", $null)
                    } -Descending

            if ($folders.Count -gt 1) {
                $rollbackFolder = $folders[1].FullName
                Write-Host "Found rollback candidate: $rollbackFolder"
                
                # Perform the rollback
                $rollbackResult = Invoke-Command -Session $session -ScriptBlock {
                    param($rollbackFolder, $webApplicationName)
                    
                    try {
                        # Load IIS module if needed
                        if (-not (Get-Module -Name WebAdministration -ErrorAction SilentlyContinue)) {
                            Import-Module WebAdministration
                        }
                        
                        # Ensure IIS drive exists
                        if (-not (Test-Path 'IIS:\')) {
                            New-PSDrive -Name IIS -PSProvider WebAdministration -Root 'MACHINE/WEBROOT/APPHOST' -ErrorAction Stop | Out-Null
                        }
                        
                        $sitePath = "IIS:\Sites\Default Web Site\$webApplicationName"
                        if (-not (Test-Path $sitePath)) {
                            throw "IIS application path does not exist: $sitePath"
                        }
                        
                        $currentPath = (Get-ItemProperty -Path $sitePath).physicalPath
                        
                        if ($currentPath -ne $rollbackFolder) {
                            Set-ItemProperty -Path $sitePath -Name physicalPath -Value $rollbackFolder
                            Write-Host "Rollback successful. Path changed from:"
                            Write-Host "$currentPath"
                            Write-Host "to:"
                            Write-Host "$rollbackFolder"
                            return $true
                        }
                        else {
                            Write-Host "Already pointing to rollback folder. No change needed."
                            return $false
                        }
                    }
                    catch {
                        Write-Host "Rollback failed: $($_.Exception.Message)"
                        return $false
                    }
                } -ArgumentList $rollbackFolder, $webApplicationName
                
                return $rollbackResult
            }
            else {
                Write-Host "[ERROR] No suitable rollback folder found in $deploymentRoot"
                return $false
            }
        }
        catch {
            Write-Host "[ERROR] Rollback execution failed on $server"
            Write-Host "Details: $($_.Exception.Message)"
            return $false
        }
        finally {
            if ($session) { Remove-PSSession $session -ErrorAction SilentlyContinue }
        }
    }
    catch {
        Write-Host "[ERROR] Connection failed during rollback on $server"
        Write-Host "Details: $($_.Exception.Message)"
        return $false
    }
}

# Main execution
try {
    # Get credentials from variable group
    $securePassword = ConvertTo-SecureString "$(AdminPassword)" -AsPlainText -Force
    $cred = New-Object System.Management.Automation.PSCredential("$(AdminUserName)", $securePassword)
    
    # Mask sensitive output
    Write-Host "Using service account: $(AdminUserName)"
    Write-Host "##vso[task.setvariable variable=AdminPassword]null"
    
    # Process each application
    foreach ($app in $config.applications) {
        Write-Host "`nProcessing application: $($app.name)"
        
        $appSuccess = $true
        $appRollbackAttempted = $false
        
        # Validate required properties
        $requiredProps = @('servers', 'deploymentRoot', 'webApplicationName', 'healthCheckUrl')
        foreach ($prop in $requiredProps) {
            if (-not $app.$prop) {
                Write-Host "##vso[task.logissue type=error]Application $($app.name) missing required property: $prop"
                $appSuccess = $false
                continue
            }
        }
        
        if (-not $appSuccess) { 
            $global:overallSuccess = $false
            continue 
        }
        
        # Process each server
        foreach ($server in $app.servers) {
            Write-Host "`n=== Processing server: $server ==="
            
            $healthStatus = Invoke-HealthCheck -server $server -healthCheckUrl $app.healthCheckUrl -cred $cred
            
            if (-not $healthStatus) {
                $appSuccess = $false
                $rollbackResult = Invoke-Rollback -server $server -deploymentRoot $app.deploymentRoot `
                    -webApplicationName $app.webApplicationName -cred $cred
                
                if ($rollbackResult) {
                    $appRollbackAttempted = $true
                    $global:anyRollbackAttempted = $true
                }
            }
        }
        
        # Application summary
        if ($appSuccess) {
            Write-Host "`n[APPLICATION RESULT] $($app.name) - All health checks passed"
        }
        elseif ($appRollbackAttempted) {
            Write-Host "`n[APPLICATION RESULT] $($app.name) - Health checks failed but rollback was attempted"
        }
        else {
            Write-Host "`n[APPLICATION RESULT] $($app.name) - Health checks failed and rollback could not be completed"
        }
        
        if (-not $appSuccess) { $global:overallSuccess = $false }
    }
    
    # Final status
    if ($global:overallSuccess) {
        Write-Host "`n[FINAL RESULT] All applications healthy"
        exit 0
    }
    elseif ($global:anyRollbackAttempted) {
        Write-Host "`n[FINAL RESULT] Some applications failed but rollbacks were attempted"
        exit 1
    }
    else {
        Write-Host "`n[FINAL RESULT] Applications failed and rollbacks could not be completed"
        exit 1
    }
}
catch {
    Write-Host "`n[CRITICAL ERROR] Unexpected failure in health check process"
    Write-Host "Details: $($_.Exception.Message)"
    exit 1
}
'@
    }
}
-----------------------------------------------------------------------------------------------------------------
