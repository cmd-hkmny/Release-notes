# Work Items Tree - Full Hierarchy with All Children
if ($filteredWorkItems.Count -gt 0) {
    Write-Host "üìÇ Building complete work item hierarchy (Epic‚ÜíFeature‚ÜíPBI/Bug/Task)..."

    # Step 1: Initialize collections
    $allWorkItems = @{}
    $childToParentMap = @{}
    $parentToChildrenMap = @{}
    $missingParents = @{}
    
    # First pass - collect all initial work items
    foreach ($item in $filteredWorkItems) {
        if ($item -and $item.id -and $item.fields) {
            $allWorkItems[$item.id] = $item
        }
    }

    # Step 2: Build complete relationship hierarchy
    $queue = [System.Collections.Queue]::new(@($allWorkItems.Keys))
    $processedItems = @{}
    $maxDepth = 10  # Increased depth for complex hierarchies

    while ($queue.Count -gt 0) {
        $itemId = $queue.Dequeue()
        
        if ($processedItems[$itemId]) { continue }
        $processedItems[$itemId] = $true

        try {
            $wiWithRelations = Invoke-RestMethod `
                -Uri "$orgUrl/$PROJECT_NAME/_apis/wit/workitems/$($itemId)?`$expand=relations&api-version=$WIT_API_VERSION" `
                -Headers $authHeader `
                -ErrorAction Stop
            
            foreach ($relation in $wiWithRelations.relations) {
                if ($relation.rel -eq "System.LinkTypes.Hierarchy-Reverse") {
                    $parentId = [int]($relation.url -split '/')[-1]
                    
                    # Record relationship
                    $childToParentMap[$itemId] = $parentId
                    if (-not $parentToChildrenMap.ContainsKey($parentId)) {
                        $parentToChildrenMap[$parentId] = @()
                    }
                    if ($parentToChildrenMap[$parentId] -notcontains $itemId) {
                        $parentToChildrenMap[$parentId] += $itemId
                    }
                    
                    # Fetch parent if not already loaded
                    if (-not $allWorkItems.ContainsKey($parentId)) {
                        try {
                            $parentItem = Invoke-RestMethod `
                                -Uri "$orgUrl/$PROJECT_NAME/_apis/wit/workitems/$($parentId)?api-version=$WIT_API_VERSION" `
                                -Headers $authHeader `
                                -ErrorAction Stop
                            
                            if ($parentItem -and $parentItem.id -and $parentItem.fields) {
                                $allWorkItems[$parentId] = $parentItem
                                Write-Host "‚úÖ Found parent item $parentId (type: $($parentItem.fields.'System.WorkItemType')) for child $itemId"
                                $queue.Enqueue($parentId)
                            }
                        } catch {
                            Write-Host "‚ö†Ô∏è Could not fetch parent item $parentId: $($_.Exception.Message)"
                            $missingParents[$parentId] = $true
                            # Add placeholder
                            $allWorkItems[$parentId] = @{
                                id = $parentId
                                fields = @{
                                    'System.WorkItemType' = 'Unknown'
                                    'System.Title' = '[Parent not accessible]'
                                }
                                url = "$orgUrl/$PROJECT_NAME/_workitems/edit/$parentId"
                            }
                        }
                    }
                }
            }
        } catch {
            Write-Host "‚ö†Ô∏è Failed to fetch relations for item ${itemId}: $($_.Exception.Message)"
        }
    }

    # Step 3: Define display settings
    $emojiMap = @{
        'Epic'    = 'üì¶'
        'Feature' = 'üåü'
        'Product Backlog Item' = 'üìå'
        'Bug'     = 'üêû'
        'Task'    = 'üîß'
        'User Story' = 'üìñ'
        'Issue'   = '‚ùó'
        'Unknown' = '‚ùì'
    }

    $typeOrder = @('Epic','Feature','Product Backlog Item','User Story','Bug','Task','Issue','Unknown')

    # Step 4: Build the hierarchy display
    function Build-FullHierarchy {
        param (
            [Parameter(Mandatory)][int]$itemId,
            [Parameter(Mandatory)][hashtable]$allItems,
            [Parameter(Mandatory)][hashtable]$parentToChildrenMap,
            [Parameter(Mandatory)][hashtable]$emojiMap,
            [ref]$displayedItems,
            [int]$level = 0
        )

        $item = $allItems[$itemId]
        if (-not $item -or -not $item.fields) { return "" }
        if ($displayedItems.Value[$itemId]) { return "" }
        $displayedItems.Value[$itemId] = $true

        $indent = '    ' * $level
        $type = $item.fields.'System.WorkItemType' ?? 'Unknown'
        $icon = $emojiMap[$type] ?? 'üîπ'

        $display = "$indent- $icon **$type #$($item.id)**: [$($item.fields.'System.Title')]($($item.url ?? "$orgUrl/$PROJECT_NAME/_workitems/edit/$itemId"))`n"

        if ($parentToChildrenMap.ContainsKey($itemId)) {
            # Sort children by work item type and then by ID
            $sortedChildren = $parentToChildrenMap[$itemId] | Sort-Object {
                $childType = $allItems[$_].fields.'System.WorkItemType' ?? 'Unknown'
                $typeOrder.IndexOf($childType), $_
            }
            
            foreach ($childId in $sortedChildren) {
                if ($allItems.ContainsKey($childId)) {
                    $display += Build-FullHierarchy `
                        -itemId $childId `
                        -allItems $allItems `
                        -parentToChildrenMap $parentToChildrenMap `
                        -emojiMap $emojiMap `
                        -displayedItems $displayedItems `
                        -level ($level + 1)
                }
            }
        }

        return $display
    }

    # Step 5: Generate the output
    $mdContent += "`n## üå≥ **Complete Work Item Hierarchy**`n"
    
    # Find root items (items without parents in our set)
    $rootItems = @($allWorkItems.Values) | Where-Object { 
        -not $childToParentMap.ContainsKey($_.id) -and 
        $_.fields.'System.WorkItemType' -in @('Epic','Feature','Product Backlog Item','User Story')
    } | Sort-Object { 
        $typeOrder.IndexOf($_.fields.'System.WorkItemType'), $_.id
    }

    $displayedItems = @{}  # Track displayed items to prevent duplicates

    if ($rootItems.Count -gt 0) {
        foreach ($rootItem in $rootItems) {
            $hierarchy = Build-FullHierarchy `
                -itemId $rootItem.id `
                -allItems $allWorkItems `
                -parentToChildrenMap $parentToChildrenMap `
                -emojiMap $emojiMap `
                -displayedItems ([ref]$displayedItems)
            
            if (-not [string]::IsNullOrEmpty($hierarchy)) {
                $mdContent += $hierarchy
            }
        }
    } else {
        $mdContent += "_No root items found. Showing all work items:_`n"
    }

    # Show any remaining items not displayed in hierarchy
    $remainingItems = @($allWorkItems.Values) | Where-Object { -not $displayedItems[$_.id] } | Sort-Object {
        $typeOrder.IndexOf($_.fields.'System.WorkItemType'), $_.id
    }

    if ($remainingItems.Count -gt 0) {
        $mdContent += "`n### Other Work Items`n"
        foreach ($item in $remainingItems) {
            $type = $item.fields.'System.WorkItemType' ?? 'Unknown'
            $icon = $emojiMap[$type] ?? 'üîπ'
            $parentInfo = if ($childToParentMap.ContainsKey($item.id)) { " (child of #$($childToParentMap[$item.id]))" }
            $mdContent += "- $icon **$type #$($item.id)$parentInfo**: [$($item.fields.'System.Title')]($($item.url ?? "$orgUrl/$PROJECT_NAME/_workitems/edit/$($item.id)"))`n"
        }
    }

    # Show missing parents if any
    if ($missingParents.Count -gt 0) {
        $mdContent += "`n### üîç Missing Parent References`n"
        $mdContent += "The following parent work items are referenced but couldn't be loaded:`n"
        foreach ($missingId in ($missingParents.Keys | Sort-Object)) {
            $mdContent += "- ‚ùì #$missingId`n"
        }
    }
}
