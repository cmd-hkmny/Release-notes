# Get linked work items and their full hierarchy (parents like Features and Epics)
Write-Host "🔗 Fetching linked work items and their hierarchy..."

$workItemQueue = New-Object System.Collections.Queue
$allWorkItems = @{}
$relations = @{}

# Fetch WI from PRs
$filteredPRs | ForEach-Object {
    try {
        $prId = $_.pullRequestId
        $linked = Invoke-RestMethod `
            -Uri "$orgUrl/$PROJECT_NAME/_apis/git/repositories/$REPO_NAME/pullRequests/$prId/workitems?api-version=$GIT_API_VERSION" `
            -Headers $authHeader
        foreach ($ref in $linked.value) {
            $workItemQueue.Enqueue($ref.id)
        }
    } catch {
        Write-Host "⚠️ Could not fetch work items for PR $prId"
    }
}

function Fetch-WorkItemWithParents {
    param (
        [int]$id
    )
    if ($allWorkItems.ContainsKey($id)) {
        return  # Already fetched
    }

    $wi = Invoke-RestMethod -Uri "$orgUrl/_apis/wit/workitems/$id?`$expand=relations&api-version=$WIT_API_VERSION" -Headers $authHeader
    $allWorkItems[$id] = $wi

    if ($wi.relations) {
        foreach ($rel in $wi.relations) {
            if ($rel.rel -eq "System.LinkTypes.Hierarchy-Reverse") {
                $parentId = [int]($rel.url -split '/')[-1]
                if (-not $relations.ContainsKey($parentId)) {
                    $relations[$parentId] = @()
                }
                $relations[$parentId] += $id

                # Recursively fetch parent
                Fetch-WorkItemWithParents -id $parentId
            }
        }
    }
}

# Process the queue
while ($workItemQueue.Count -gt 0) {
    $wid = $workItemQueue.Dequeue()
    try {
        Fetch-WorkItemWithParents -id $wid
    } catch {
        Write-Host "❌ Failed to fetch work item $wid: $_"
    }
}

# Identify root work items (those not children of anyone)
$rootItems = @()
foreach ($itemId in $allWorkItems.Keys) {
    $isChild = $false
    foreach ($p in $relations.Values) {
        if ($p -contains $itemId) {
            $isChild = $true
            break
        }
    }
    if (-not $isChild) {
        $rootItems += $itemId
    }
}

# Emoji map
$emojiMap = @{
    'Epic'    = '📦'
    'Feature' = '🌟'
    'Product Backlog Item' = '📌'
    'Bug'     = '🐞'
    'Task'    = '🔧'
}

function Build-WorkItemTree {
    param (
        [int]$itemId,
        [int]$level = 0
    )
    if (-not $allWorkItems.ContainsKey($itemId)) { return "" }

    $item = $allWorkItems[$itemId]
    $indent = '    ' * $level
    $type = $item.fields.'System.WorkItemType'
    $icon = $emojiMap[$type] ?? '🔹'
    $title = $item.fields.'System.Title'
    $link = "$orgUrl/$PROJECT_NAME/_workitems/edit/$itemId"

    $line = "$indent- $icon **$type #$itemId**: [$title]($link)`n"

    if ($relations.ContainsKey($itemId)) {
        foreach ($childId in ($relations[$itemId] | Sort-Object)) {
            $line += Build-WorkItemTree -itemId $childId -level ($level + 1)
        }
    }

    return $line
}

# Output section
$mdContent += "`n## 📌 **Work Items (Epic > Feature > PBI)**`n"

if ($rootItems.Count -gt 0) {
    foreach ($rootId in ($rootItems | Sort-Object)) {
        $mdContent += Build-WorkItemTree -itemId $rootId
    }
} else {
    $mdContent += "_No hierarchical structure found._`n"
}
