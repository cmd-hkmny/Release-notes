
# Add health check task using PowerShellOnTargetMachines@3
$healthCheckTask = [pscustomobject]@{
    taskId   = "fc5f5b8e-43f1-47dd-b891-74c4eac0a19f"  # taskId for PowerShellOnTargetMachines@3
    version  = "3.*"
    name     = "HealthCheck_PROD"
    enabled  = $true
    inputs   = @{
        Machines        = "CHEAAPIDV03,CHEAAPIDV04"
        AdminUserName   = "$(adminUsername)"
        AdminPassword   = "$(adminPassword)"
        Target          = "InlineScript"
        Protocol        = "Http"
        ScriptArguments = ""
        InlineScript    = @'
          Write-Host "Running health check on $env:COMPUTERNAME"
          $url = "http://localhost/api/health"
          $resp = Invoke-WebRequest -Uri $url -UseBasicParsing -TimeoutSec 10 -ErrorAction Stop
          if ($resp.StatusCode -eq 200) {
              Write-Host "Health check passed"
          } else {
              Write-Error "Health check failed with status: $($resp.StatusCode)"
          }
        '@
    }
}
$phase.workflowTasks += $healthCheckTask
========================================================================================================================================
$healthCheckTask = [pscustomobject]@{
    taskId   = "2f1b7e86-cc74-4d9b-b3cf-f4c4f3c61b86"  # PowerShell@2
    version  = "2.*"
    name     = "HealthCheck_PROD"
    enabled  = $true
    inputs   = @{
        targetType     = "inline"
        script         = @'
            $servers = @("CHEAAPIDV03", "CHEAAPIDV04")
            $username = "LEDGER\\SVC-AUTODEPD01"
            $password = ConvertTo-SecureString "409598359eriogseu90weu9jiogseu90ehuierio" -AsPlainText -Force
            $creds = New-Object System.Management.Automation.PSCredential($username, $password)

            foreach ($server in $servers) {
                Write-Host "Running health check on $server"

                try {
                    Invoke-Command -ComputerName $server -Credential $creds -ScriptBlock {
                        $url = "http://localhost/api/health"
                        try {
                            $resp = Invoke-WebRequest -Uri $url -UseBasicParsing -TimeoutSec 10 -ErrorAction Stop
                            if ($resp.StatusCode -eq 200) {
                                Write-Host "[$env:COMPUTERNAME] Health check passed"
                            } else {
                                Write-Error "[$env:COMPUTERNAME] Health check failed with status: $($resp.StatusCode)"
                                exit 1
                            }
                        } catch {
                            Write-Error "[$env:COMPUTERNAME] Error during health check: $($_.Exception.Message)"
                            exit 1
                        }
                    }
                } catch {
                    Write-Error "Could not connect to $server: $($_.Exception.Message)"
                    exit 1
                }
            }
        '@
    }
}
------------------------------------------------------------------------------------------------------
$healthCheckTask = @{
    taskId      = "e213ff0f-5d5c-4791-802d-52ea3e7be1f1"  # PowerShell@2
    version     = "2.*"
    name        = "HealthCheckAndRollback"
    enabled     = $true
    inputs      = @{
        targetType  = "inline"
        script      = @"
\$servers = @('CHEAAPIDV03', 'CHEAAPIDV04')  # Target servers
\$username = '$($ServerConfig.AdminUserName)'  # e.g., 'DOMAIN\\User'
\$password = ConvertTo-SecureString '$($ServerConfig.AdminPassword)' -AsPlainText -Force
\$cred = New-Object System.Management.Automation.PSCredential(\$username, \$password)

\$DeploymentRoot = '$($ServerConfig.DeploymentRoot)'
\$WebApplicationName = '$($ServerConfig.WebApplicationName)'

foreach (\$server in \$servers) {
    Write-Host "Connecting to \$server..."

    try {
        \$session = New-PSSession -ComputerName \$server -Credential \$cred -ErrorAction Stop

        \$response = Invoke-Command -Session \$session -ScriptBlock {
            Invoke-WebRequest -Uri 'http://localhost/api/health' -UseBasicParsing -TimeoutSec 10
        }

        if (\$response.StatusCode -eq 200) {
            Write-Host "Health check passed on \$server"
        } else {
            throw "Non-200 response: \$response.StatusCode"
        }

        Remove-PSSession \$session
    } catch {
        Write-Host "Health check failed or could not connect to \$server. Attempting rollback..."

        try {
            if (-not \$session) {
                \$session = New-PSSession -ComputerName \$server -Credential \$cred -ErrorAction Stop
            }

            \$folders = Invoke-Command -Session \$session -ScriptBlock {
                param(\$DeploymentRoot)
                Get-ChildItem -Path \$DeploymentRoot -Directory |
                    Where-Object { \$_.Name -match '^\d+(\.\d+)*_\d{8}\.\d{6}\$' } |
                    Sort-Object {
                        \$timestamp = \$_.Name.Split('_')[1]
                        [datetime]::ParseExact(\$timestamp, 'ddMMyyyy.HHmmss', \$null)
                    } -Descending
            } -ArgumentList \$DeploymentRoot

            if (\$folders.Count -gt 1) {
                \$rollbackFolder = \$folders[1].FullName
                Invoke-Command -Session \$session -ScriptBlock {
                    param(\$rollbackFolder, \$WebApplicationName)
                    Set-ItemProperty -Path "IIS:\\Sites\\Default Web Site\\\$WebApplicationName" -Name physicalPath -Value \$rollbackFolder
                } -ArgumentList \$rollbackFolder, \$WebApplicationName

                Write-Host "Rolled back to: \$rollbackFolder on \$server"
            } else {
                Write-Host "No rollback folder found on \$server"
            }

            Remove-PSSession \$session
        } catch {
            Write-Host "Rollback failed on \$server: \$($_.Exception.Message)"
            if (\$session) { Remove-PSSession \$session }
        }
    }
}
"@
    }
}

--------------------------------------------------------------------------
$healthCheckTask = @{
    taskId      = "e213ff0f-5d5c-4791-802d-52ea3e7be1f1"  # PowerShell@2
    version     = "2.*"
    name        = "HealthCheckAndRollback"
    enabled     = $true
    inputs      = @{
        targetType  = "inline"
        script      = @'
$servers = @("CHEAAPIDV03", "CHEAAPIDV04")  # Target servers
$username = "$(AdminUserName)"  # e.g., 'DOMAIN\User'
$password = ConvertTo-SecureString "$(AdminPassword)" -AsPlainText -Force
$cred = New-Object System.Management.Automation.PSCredential($username, $password)

$DeploymentRoot = "$(DeploymentRoot)"
$WebApplicationName = "$(WebApplicationName)"

foreach ($server in $servers) {
    Write-Host "Connecting to $server..."

    try {
        $session = New-PSSession -ComputerName $server -Credential $cred -ErrorAction Stop

        $response = Invoke-Command -Session $session -ScriptBlock {
            Invoke-WebRequest -Uri "http://localhost/api/health" -UseBasicParsing -TimeoutSec 10
        }

        if ($response.StatusCode -eq 200) {
            Write-Host "Health check passed on $server"
        } else {
            throw "Non-200 response: $($response.StatusCode)"
        }

        Remove-PSSession $session
    } catch {
        Write-Host "Health check failed or could not connect to $server. Attempting rollback..."

        try {
            if (-not $session) {
                $session = New-PSSession -ComputerName $server -Credential $cred -ErrorAction Stop
            }

            $folders = Invoke-Command -Session $session -ScriptBlock {
                param($DeploymentRoot)
                Get-ChildItem -Path $DeploymentRoot -Directory |
                    Where-Object { $_.Name -match "^\d+(\.\d+)*_\d{8}\.\d{6}$" } |
                    Sort-Object {
                        $timestamp = $_.Name.Split("_")[1]
                        [datetime]::ParseExact($timestamp, "ddMMyyyy.HHmmss", $null)
                    } -Descending
            } -ArgumentList $DeploymentRoot

            if ($folders.Count -gt 1) {
                $rollbackFolder = $folders[1].FullName
                Invoke-Command -Session $session -ScriptBlock {
                    param($rollbackFolder, $WebApplicationName)
                    Set-ItemProperty -Path ("IIS:\Sites\Default Web Site\" + $WebApplicationName) -Name physicalPath -Value $rollbackFolder
                } -ArgumentList $rollbackFolder, $WebApplicationName

                Write-Host "Rolled back to: $rollbackFolder on $server"
            } else {
                Write-Host "No rollback folder found on $server"
            }

            Remove-PSSession $session
        } catch {
            Write-Host "Rollback failed on $server: $($_.Exception.Message)"
            if ($session) { Remove-PSSession $session }
        }
    }
}
'@
    }
}
==================================================================

foreach ($server in $servers) {
    Write-Host "Connecting to $server..."

    try {
        $session = New-PSSession -ComputerName $server -Credential $cred -ErrorAction Stop

        try {
            $response = Invoke-Command -Session $session -ScriptBlock {
                Invoke-WebRequest -Uri "http://localhost/api/health" -UseBasicParsing -TimeoutSec 10
            }

            if ($response.StatusCode -eq 200) {
                Write-Host "Health check passed on $server"
            } else {
                throw "Non-200 response: $($response.StatusCode)"
            }
        }
        catch {
            Write-Host "Health check failed on $server. Attempting rollback..."

            $folders = Invoke-Command -Session $session -ScriptBlock {
                param($DeploymentRoot)
                Get-ChildItem -Path $DeploymentRoot -Directory |
                    Where-Object { $_.Name -match "^\d+(\.\d+)*_\d{8}\.\d{6}$" } |
                    Sort-Object {
                        $timestamp = $_.Name.Split("_")[1]
                        [datetime]::ParseExact($timestamp, "ddMMyyyy.HHmmss", $null)
                    } -Descending
            } -ArgumentList $DeploymentRoot

            if ($folders.Count -gt 1) {
                $rollbackFolder = $folders[1].FullName
                Invoke-Command -Session $session -ScriptBlock {
                    param($rollbackFolder, $WebApplicationName)
                    Set-ItemProperty -Path ("IIS:\Sites\Default Web Site\" + $WebApplicationName) -Name physicalPath -Value $rollbackFolder
                } -ArgumentList $rollbackFolder, $WebApplicationName

                Write-Host "Rolled back to: $rollbackFolder on $server"
            } else {
                Write-Host "No rollback folder found on $server"
            }
        }

        Remove-PSSession $session
    }
    catch {
        Write-Host "Could not connect to $server or unexpected error: $($_.Exception.Message)"
        if ($session) { Remove-PSSession $session }
    }
}
'@
    }
}
===========================================================================================
$healthCheckTask = @{
    taskId      = "e213ff0f-5d5c-4791-802d-52ea3e7be1f1"  # PowerShell@2
    version     = "2.*"
    name        = "HealthCheckAndRollback"
    enabled     = $true
    inputs      = @{
        targetType  = "inline"
        script      = @'
# Enable TLS 1.2
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

# Configuration
$servers = @("CHEAAPIDV03", "CHEAAPIDV04")
$DeploymentRoot = "$(DeploymentRoot)"
$WebApplicationName = "$(WebApplicationName)"
$healthCheckUrl = "http://localhost/api/health"
$timeoutSeconds = 15

# Initialize counters
$global:success = $true
$global:rollbackAttempted = $false

function Invoke-HealthCheck {
    param (
        [string]$server,
        [System.Management.Automation.PSCredential]$cred
    )
    
    try {
        Write-Host "`n=== Health Check on $server ==="
        
        # Create remote session
        $sessionParams = @{
            ComputerName = $server
            Credential = $cred
            SessionOption = New-PSSessionOption -IdleTimeout (($timeoutSeconds + 5) * 1000
            ErrorAction = 'Stop'
        }
        $session = New-PSSession @sessionParams
        
        try {
            # Test basic connectivity first
            $null = Invoke-Command -Session $session -ScriptBlock { $true } -ErrorAction Stop
            
            # Perform health check
            $response = Invoke-Command -Session $session -ScriptBlock {
                param($url, $timeout)
                try {
                    Invoke-WebRequest -Uri $url -UseBasicParsing -TimeoutSec $timeout
                } catch {
                    # Return the exception details if the request fails
                    @{
                        StatusCode = 500
                        StatusDescription = $_.Exception.Message
                    }
                }
            } -ArgumentList $healthCheckUrl, $timeoutSeconds
            
            if ($response.StatusCode -eq 200) {
                Write-Host "[SUCCESS] Health check passed on $server"
                return $true
            } else {
                Write-Host "[FAILURE] Health check failed on $server (Status: $($response.StatusCode))"
                Write-Host "Response: $($response.StatusDescription)"
                return $false
            }
        }
        finally {
            if ($session) { Remove-PSSession $session -ErrorAction SilentlyContinue }
        }
    }
    catch {
        Write-Host "[ERROR] Connection/health check failed on $server"
        Write-Host "Details: $($_.Exception.Message)"
        return $false
    }
}

function Invoke-Rollback {
    param (
        [string]$server,
        [System.Management.Automation.PSCredential]$cred
    )
    
    try {
        Write-Host "`n=== Attempting Rollback on $server ==="
        
        $sessionParams = @{
            ComputerName = $server
            Credential = $cred
            SessionOption = New-PSSessionOption -IdleTimeout 300000
            ErrorAction = 'Stop'
        }
        $session = New-PSSession @sessionParams
        
        try {
            # Get available deployment folders
            $folders = Invoke-Command -Session $session -ScriptBlock {
                param($DeploymentRoot)
                Get-ChildItem -Path $DeploymentRoot -Directory |
                    Where-Object { $_.Name -match "^\d+(\.\d+)*_\d{8}\.\d{6}$" } |
                    Sort-Object {
                        $timestamp = $_.Name.Split("_")[1]
                        [datetime]::ParseExact($timestamp, "ddMMyyyy.HHmmss", $null)
                    } -Descending
            } -ArgumentList $DeploymentRoot

            if ($folders.Count -gt 1) {
                $rollbackFolder = $folders[1].FullName
                Write-Host "Found rollback candidate: $rollbackFolder"
                
                # Perform the rollback
                $rollbackResult = Invoke-Command -Session $session -ScriptBlock {
                    param($rollbackFolder, $WebApplicationName)
                    try {
                        $sitePath = "IIS:\Sites\Default Web Site\$WebApplicationName"
                        $currentPath = (Get-ItemProperty -Path $sitePath).physicalPath
                        
                        if ($currentPath -ne $rollbackFolder) {
                            Set-ItemProperty -Path $sitePath -Name physicalPath -Value $rollbackFolder
                            Write-Host "Rollback successful. Path changed from:"
                            Write-Host "$currentPath"
                            Write-Host "to:"
                            Write-Host "$rollbackFolder"
                            return $true
                        } else {
                            Write-Host "Already pointing to rollback folder. No change needed."
                            return $false
                        }
                    } catch {
                        Write-Host "Rollback failed: $($_.Exception.Message)"
                        return $false
                    }
                } -ArgumentList $rollbackFolder, $WebApplicationName
                
                if ($rollbackResult) {
                    $script:global:rollbackAttempted = $true
                    Write-Host "[SUCCESS] Rollback completed on $server"
                } else {
                    Write-Host "[WARNING] Rollback not performed on $server"
                }
            } else {
                Write-Host "[ERROR] No suitable rollback folder found on $server"
            }
        }
        finally {
            if ($session) { Remove-PSSession $session -ErrorAction SilentlyContinue }
        }
    }
    catch {
        Write-Host "[ERROR] Rollback failed on $server"
        Write-Host "Details: $($_.Exception.Message)"
    }
}

# Main execution
try {
    # Create credentials (passed as pipeline variables)
    $securePassword = ConvertTo-SecureString "$(AdminPassword)" -AsPlainText -Force
    $cred = New-Object System.Management.Automation.PSCredential("$(AdminUserName)", $securePassword)
    
    # Perform health checks
    foreach ($server in $servers) {
        $healthStatus = Invoke-HealthCheck -server $server -cred $cred
        if (-not $healthStatus) {
            $global:success = $false
            Invoke-Rollback -server $server -cred $cred
        }
    }
    
    # Final status
    if ($global:success) {
        Write-Host "`n[RESULT] All health checks passed successfully"
        exit 0
    } elseif ($global:rollbackAttempted) {
        Write-Host "`n[RESULT] Health checks failed but rollback was attempted"
        exit 1
    } else {
        Write-Host "`n[RESULT] Health checks failed and rollback could not be completed"
        exit 1
    }
}
catch {
    Write-Host "`n[CRITICAL ERROR] Unexpected failure in health check process"
    Write-Host "Details: $($_.Exception.Message)"
    exit 1
}
'@
    }
}
---------------------------------------------------------------
foreach ($server in $servers) {
    # First test basic connectivity
    $connectionTest = Test-RemoteConnectivity -server $server -cred $cred
    
    if (-not $connectionTest) {
        Write-Host "##vso[task.logissue type=error]Cannot proceed - failed to connect to $server"
        $global:success = $false
        continue
    }
    
    # Only proceed with health check if connection test passed
------------------------------------------------------------------
function Test-RemoteConnectivity {
    param (
        [string]$server,
        [System.Management.Automation.PSCredential]$cred
    )
    
    try {
        Write-Host "`n=== Testing connection to $server ==="
        
        # Test basic WinRM connectivity first
        $sessionParams = @{
            ComputerName = $server
            Credential = $cred
            SessionOption = New-PSSessionOption -IdleTimeout 60000
            ErrorAction = 'Stop'
        }
        
        # Create session
        $session = New-PSSession @sessionParams
        Write-Host "[SUCCESS] Established PowerShell Remoting session to $server"
        
        try {
            # Test basic command execution
            $osInfo = Invoke-Command -Session $session -ScriptBlock {
                [PSCustomObject]@{
                    ComputerName = $env:COMPUTERNAME
                    OSVersion = [System.Environment]::OSVersion.VersionString
                    PSVersion = $PSVersionTable.PSVersion
                    Time = Get-Date
                    Disks = Get-Volume | Select-Object DriveLetter, SizeRemaining, Size
                }
            }
            
            Write-Host "`n[REMOTE SERVER DETAILS]"
            Write-Host "Computer Name: $($osInfo.ComputerName)"
            Write-Host "OS Version: $($osInfo.OSVersion)"
            Write-Host "PowerShell Version: $($osInfo.PSVersion)"
            Write-Host "Current Time: $($osInfo.Time)"
            
            Write-Host "`n[DISK INFORMATION]"
            $osInfo.Disks | ForEach-Object {
                $freeGB = [math]::Round($_.SizeRemaining/1GB, 2)
                $totalGB = [math]::Round($_.Size/1GB, 2)
                Write-Host "Drive $($_.DriveLetter): $freeGB GB free of $totalGB GB"
            }
            
            # List top 5 processes by memory usage
            $processes = Invoke-Command -Session $session -ScriptBlock {
                Get-Process | Sort-Object WS -Descending | Select-Object -First 5 | 
                Select-Object ProcessName, Id, WS, CPU
            }
            
            Write-Host "`n[TOP PROCESSES BY MEMORY]"
            $processes | ForEach-Object {
                $memMB = [math]::Round($_.WS/1MB, 2)
                Write-Host "$($_.ProcessName) (PID $($_.Id)): $memMB MB"
            }
            
            return $true
        }
        finally {
            if ($session) { Remove-PSSession $session -ErrorAction SilentlyContinue }
        }
    }
    catch {
        Write-Host "[ERROR] Failed to connect to $server"
        Write-Host "Details: $($_.Exception.Message)"
        return $false
    }
}
--------------------------------------------------------
