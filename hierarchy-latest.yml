# Work Items Tree (Simplified)
if ($filteredWorkItems.Count -gt 0) {
    Write-Host "üìÇ Building simplified hierarchical work item tree..."

    # Collect all work items
    $allWorkItems = @{}
    $childToParent = @{}
    $parentToChildren = @{}

    foreach ($item in $filteredWorkItems) {
        if ($item -and $item.id -and $item.fields) {
            $allWorkItems[$item.id] = $item
        }
    }

    # Build hierarchy by fetching parents
    foreach ($item in $filteredWorkItems) {
        $itemId = $item.id
        try {
            $wi = Invoke-RestMethod `
                -Uri "$orgUrl/$PROJECT_NAME/_apis/wit/workitems/$itemId?`$expand=relations&api-version=$WIT_API_VERSION" `
                -Headers $authHeader
            $allWorkItems[$itemId] = $wi

            foreach ($rel in $wi.relations) {
                if ($rel.rel -eq "System.LinkTypes.Hierarchy-Reverse") {
                    $parentId = [int]($rel.url.Split('/')[-1])
                    $childToParent[$itemId] = $parentId

                    if (-not $parentToChildren.ContainsKey($parentId)) {
                        $parentToChildren[$parentId] = @()
                    }
                    $parentToChildren[$parentId] += $itemId

                    # Fetch and cache parent if missing
                    if (-not $allWorkItems.ContainsKey($parentId)) {
                        $parentItem = Invoke-RestMethod `
                            -Uri "$orgUrl/$PROJECT_NAME/_apis/wit/workitems/$parentId?api-version=$WIT_API_VERSION" `
                            -Headers $authHeader
                        $allWorkItems[$parentId] = $parentItem
                    }
                }
            }
        } catch {
            Write-Host "‚ö†Ô∏è Failed to get relations for $itemId: $_"
        }
    }

    # Emoji map
    $emojiMap = @{
        'Epic'    = 'üì¶'
        'Feature' = 'üåü'
        'Product Backlog Item' = 'üìå'
        'Bug'     = 'üêû'
        'Task'    = 'üîß'
        'Issue'   = '‚ùó'
    }

    # Recursive hierarchy formatter
    function Format-Tree {
        param (
            [int]$id,
            [int]$level = 0
        )

        if (-not $allWorkItems.ContainsKey($id)) { return "" }

        $item = $allWorkItems[$id]
        $type = $item.fields.'System.WorkItemType'
        $title = $item.fields.'System.Title'
        $icon = $emojiMap[$type] ?? 'üîπ'
        $indent = "    " * $level

        $line = "$indent- $icon **$type #$id** - $title`n"

        if ($parentToChildren.ContainsKey($id)) {
            foreach ($childId in ($parentToChildren[$id] | Sort-Object)) {
                $line += Format-Tree -id $childId -level ($level + 1)
            }
        }

        return $line
    }

    $mdContent += "`n## üìå **Work Items (Hierarchical Structure)**`n"

    # Find root items (no parent)
    $rootItems = $allWorkItems.Keys | Where-Object { -not $childToParent.ContainsKey($_) }
    foreach ($rootId in $rootItems | Sort-Object) {
        $mdContent += Format-Tree -id $rootId
    }
}
