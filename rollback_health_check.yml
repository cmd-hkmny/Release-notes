
$folders = Invoke-Command -Session $session -ScriptBlock {
    param($root)
    
    Write-Host "`n=== Scanning deployment root: $root ==="
    
    # Get all folders and show them
    $allFolders = Get-ChildItem -Path $root -Directory
    Write-Host "`nAll folders found ($($allFolders.Count)):"
    $allFolders | ForEach-Object { Write-Host " - $($_.Name)" }
    
    # Enhanced pattern to match both:
    # 1. Release-XX_YYYYMMDD.HHmmss or Release-XX YYYYMMDD.HHmmss
    # 2. X.X.X.X_YYYYMMDD.HHmmss (version numbers)
    $pattern = "^(?:Release-\d+[_ ]|(?:\d+\.)+\d+_)\d{8}\.\d{6}$"
    Write-Host "`nApplying pattern: $pattern"
    
    $matchedFolders = $allFolders | Where-Object { 
        if ($_.Name -match $pattern) {
            Write-Host " [MATCH] $($_.Name)"
            $true
        } else {
            Write-Host " [NO MATCH] $($_.Name)"
            $false
        }
    }
    
    # Sort by extracted datetime
    $sortedFolders = $matchedFolders | Sort-Object {
        # Extract the date part (after last _)
        if ($_.Name -match "_(\d{8}\.\d{6})$") {
            $datePart = $matches[1]
            try {
                $parsedDate = [datetime]::ParseExact($datePart, 'ddMMyyyy.HHmmss', $null)
                Write-Host " - $($_.Name) → $datePart → $parsedDate"
                $parsedDate
            } catch {
                Write-Host " [DATE ERROR] $($_.Name) - Invalid date: $datePart"
                [datetime]::MinValue
            }
        } else {
            Write-Host " [DATE EXTRACTION FAILED] $($_.Name)"
            [datetime]::MinValue
        }
    } -Descending
    
    Write-Host "`nSorted folders (newest first):"
    $sortedFolders | ForEach-Object { Write-Host " - $($_.Name)" }
    
    $sortedFolders
} -ArgumentList $deploymentRoot

# Rollback logic
if ($folders.Count -ge 2) {
    $current = $folders[0]
    $rollbackTarget = $folders[1]
    
    Write-Host "`n=== Rollback Selection ==="
    Write-Host "Current Version: $($current.Name)"
    Write-Host "Rollback Target: $($rollbackTarget.Name)"
    Write-Host "Full Path: $($rollbackTarget.FullName)"
    
    # Return the rollback target path
    $rollbackTarget.FullName
} else {
    $msg = "Not enough versions for rollback (found $($folders.Count), need at least 2)"
    Write-Host "##[error] $msg"
    throw $msg
}
===========================================================================================================
function Add-HealthcheckTask {
    param(
        [object]$phase,
        [object]$config
    )

    # Validate config
    if (-not $config) {
        throw "Configuration object cannot be null"
    }

    # Extract values with null checks
    $ApiServer = $config.ApiServer
    $DeploymentRoot = $config.DeploymentRoot
    $WebApplicationName = $config.DNSRepoName
    $HealthcheckUrl = $config.healthcheckUrl

    # Convert values to compressed JSON
    $serversJson = ($ApiServer -split ',' | ForEach-Object { $_.Trim() } | Where-Object { $_ }) | ConvertTo-Json -Compress
    $deploymentRootJson = $DeploymentRoot | ConvertTo-Json -Compress
    $webAppNameJson = $WebApplicationName | ConvertTo-Json -Compress
    $healthcheckUrlJson = $HealthcheckUrl | ConvertTo-Json -Compress

    # Convert to Base64
    $base64Servers = [Convert]::ToBase64String([Text.Encoding]::UTF8.GetBytes($serversJson))
    $base64DeploymentRoot = [Convert]::ToBase64String([Text.Encoding]::UTF8.GetBytes($deploymentRootJson))
    $base64WebAppName = [Convert]::ToBase64String([Text.Encoding]::UTF8.GetBytes($webAppNameJson))
    $base64HealthcheckUrl = [Convert]::ToBase64String([Text.Encoding]::UTF8.GetBytes($healthcheckUrlJson))

    $healthCheckTask = @{
        taskId = "e213ff0f-5d5c-4791-802d-52ea3e7be1f1"
        version = "2.*"
        name = "HealthcheckAndRollback"
        enabled = $true
        inputs = @{
            targetType = "inline"
            script = @'
# Decode configuration from Base64
$config = @{
    Servers = ([System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String('BASE64_SERVERS'))) | ConvertFrom-Json
    DeploymentRoot = ([System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String('BASE64_DEPLOYMENT_ROOT'))) | ConvertFrom-Json
    WebApplicationName = ([System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String('BASE64_WEBAPP_NAME'))) | ConvertFrom-Json
    HealthcheckUrl = ([System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String('BASE64_HEALTHCHECK_URL'))) | ConvertFrom-Json
}

# Enable TLS 1.2
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

# Initialize variables
$servers = $config.Servers
$DeploymentRoot = $config.DeploymentRoot
$WebApplicationName = $config.WebApplicationName
$healthcheckUrl = $config.HealthcheckUrl
$timeoutSeconds = 15

# Debug output
Write-Host "=== Configuration ==="
Write-Host "Servers: $($servers -join ', ')"
Write-Host "Deployment Root: $DeploymentRoot"
Write-Host "Web Application: $WebApplicationName"
Write-Host "Healthcheck URL: $healthcheckUrl"

# Rest of your healthcheck script...
'@ -replace 'BASE64_SERVERS', $base64Servers `
              -replace 'BASE64_DEPLOYMENT_ROOT', $base64DeploymentRoot `
              -replace 'BASE64_WEBAPP_NAME', $base64WebAppName `
              -replace 'BASE64_HEALTHCHECK_URL', $base64HealthcheckUrl
            pwsh = "true"
        }
    }

    # Add the task to the phase
    $phase.tasks += $healthCheckTask
}
===============================================================================================
# Loop through all stages to find PROD (after cloning)
foreach ($phase in $phases) {
    # Check if this is the PROD stage (adjust condition as needed)
    if ($phase.name -like "*Production*" -or $phase.name -eq "Prod") {  

        # 1. Rename tasks: Replace "Preprod" with "Prod"
        foreach ($task in $phase.tasks) {
            if ($task.name -like "*Preprod*") {
                $task.name = $task.name -replace "Preprod", "Prod"
            }
        }
=========================================================================================================    
# Get deployment folders
$folders = Invoke-Command -Session $session -ScriptBlock {
    param($root)
    
    Write-Host "`n=== Scanning deployment root: $root ==="
    
    # Get all folders and show them
    $allFolders = Get-ChildItem -Path $root -Directory
    Write-Host "`nAll folders found ($($allFolders.Count)):"
    $allFolders | ForEach-Object { Write-Host " - $($_.Name)" }
    
    # Enhanced pattern to match both:
    # 1. Release-XX_YYYYMMDD.HHmmss or Release-XX YYYYMMDD.HHmmss
    # 2. X.X.X.X_YYYYMMDD.HHmmss (version numbers)
    $pattern = "^(?:Release-\d+[_ ]|(?:\d+\.)+\d+_)\d{8}\.\d{6}$"
    Write-Host "`nApplying pattern: $pattern"
    
    $matchedFolders = $allFolders | Where-Object { 
        if ($_.Name -match $pattern) {
            Write-Host " [MATCH] $($_.Name)"
            $true
        } else {
            Write-Host " [NO MATCH] $($_.Name)"
            $false
        }
    }
    
    # Sort by extracted datetime
    $sortedFolders = $matchedFolders | Sort-Object {
        # Extract the date part (after last _)
        if ($_.Name -match "_(\d{8}\.\d{6})$") {
            $datePart = $matches[1]
            try {
                $parsedDate = [datetime]::ParseExact($datePart, 'ddMMyyyy.HHmmss', $null)
                Write-Host " - $($_.Name) → $datePart → $parsedDate"
                $parsedDate
            } catch {
                Write-Host " [DATE ERROR] $($_.Name) - Invalid date: $datePart"
                [datetime]::MinValue
            }
        } else {
            Write-Host " [DATE EXTRACTION FAILED] $($_.Name)"
            [datetime]::MinValue
        }
    } -Descending
    
    Write-Host "`nSorted folders (newest first):"
    $sortedFolders | ForEach-Object { Write-Host " - $($_.Name)" }
    
    $sortedFolders
} -ArgumentList $deploymentRoot

# Rollback logic
if ($folders.Count -ge 2) {
    $current = $folders[0]
    $rollbackTarget = $folders[1]
    
    Write-Host "`n=== Rollback Selection ==="
    Write-Host "Current Version: $($current.Name)"
    Write-Host "Rollback Target: $($rollbackTarget.Name)"
    Write-Host "Full Path: $($rollbackTarget.FullName)"
    
    # Return the rollback target path
    $rollbackTarget.FullName
} else {
    $msg = "Not enough versions for rollback (found $($folders.Count), need at least 2)"
    Write-Host "##[error] $msg"
    throw $msg
}
========================
  $folders = Invoke-Command -Session $session -ScriptBlock {
    param($root)
    
    Get-ChildItem -Path $root -Directory |
    Where-Object {
        $_.Name -match "^Release-\d+_\d{8}\.\d{6}$"
    } |
    Sort-Object {
        $datePart = $_.Name.Split('_')[-1]
        [datetime]::ParseExact($datePart, 'ddMMyyyy.HHmmss', $null)
    } -Descending
} -ArgumentList $deploymentRoot

==================================================================================================


param(
    [string]$Org,
    [string]$Project,
    [string]$Pat,
    [string]$ApiVersion = "7.1-preview.4",
    [string]$PipelineIds,
    [string]$ConfigPath,
    [string]$ApprovalGroupId
)

# Convert pipeline IDs to integers with validation
$PipelineIds = $PipelineIds -split "," | Where-Object {
    $_.Trim() -match '^\d+$'
} | ForEach-Object {
    [int]$_.Trim()
}

if (-not $PipelineIds -or $PipelineIds.Count -eq 0) {
    Write-Error "No valid numeric Pipeline IDs found. Please check the input."
    exit 1
}

# Set up authentication headers
$AuthHeader = "Basic " + [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(":$Pat"))
$Headers = @{
    "Authorization" = $AuthHeader
    "Content-Type"  = "application/json"
    "Accept"        = "application/json; api-version=$ApiVersion"
}

# Load server configuration
if ($ConfigPath -match "\.json$") {
    $ServerConfig = Get-Content -Path $ConfigPath | ConvertFrom-Json
} elseif ($ConfigPath -match "\.csv$") {
    $ServerConfig = Import-Csv -Path $ConfigPath | Select-Object -First 1
} else {
    Write-Host "Unsupported config format. Use JSON or CSV."
    exit 1
}

Function Add-ProdStage {
    param ([int]$PipelineId)

    Write-Host "`nProcessing Pipeline ID: $PipelineId"

    $url = "https://vsrm.dev.azure.com/$Org/$Project/_apis/release/definitions/${PipelineId}?api-version=$ApiVersion"
    
    try {
        # Get the existing pipeline definition
        $pipeline = Invoke-RestMethod -Uri $url -Headers $Headers -Method Get
        
        # Save original for debugging
        $pipeline | ConvertTo-Json -Depth 20 | Out-File "original_pipeline_$PipelineId.json"
        Write-Host "Saved original pipeline definition to original_pipeline_$PipelineId.json"
    } catch {
        Write-Host "ERROR fetching pipeline ID: $PipelineId. $_"
        return
    }

    # Check for pre-prod stage
    $preProdStage = $pipeline.environments | Where-Object { $_.name -eq 'pre-prod' } | Select-Object -First 1
    if (-not $preProdStage) {
        Write-Host "No pre-prod stage found in pipeline $PipelineId"
        return
    }

    # Check if prod already exists
    if ($pipeline.environments.name -contains 'prod') {
        Write-Host "PROD stage already exists in pipeline $PipelineId"
        return
    }

    # Clone the pre-prod stage
    $prodStage = $preProdStage | ConvertTo-Json -Depth 20 | ConvertFrom-Json

    # Clean up IDs and set new properties
    $prodStage.PSObject.Properties.Remove('id')
    $prodStage.name = "prod"
    $prodStage.rank = $pipeline.environments.Count + 1

    # Process deployment phases
    foreach ($phase in $prodStage.deployPhases) {
        $phase.PSObject.Properties.Remove('phaseId')
        
        # Clean task IDs
        foreach ($task in $phase.workflowTasks) {
            $task.PSObject.Properties.Remove('id')
        }

        # Add health check task (using standard PowerShell task)
        $healthCheckTask = @{
            taskId      = "e213ff0f-5d5c-4791-802d-52ea3e7be1f1"  # PowerShell task GUID
            version     = "2.*"
            name        = "HealthCheckAndRollback"
            enabled     = $true
            inputs      = @{
                targetType  = "inline"
                script      = @"
`$response = Invoke-WebRequest -Uri 'https://app-001-funtions-test/api/health' -UseBasicParsing
if (`$response.StatusCode -ne 200) {
    Write-Host 'Health check failed. Initiating rollback...'
    `$DeploymentRoot = '$($ServerConfig.DeploymentRoot)'
    `$WebApplicationName = '$($ServerConfig.WebApplicationName)'

    `$folders = Get-ChildItem -Path `$DeploymentRoot -Directory |
        Where-Object { `$_.Name -match '^\d+(\.\d+)*_\d{8}\.\d{6}$' } |
        Sort-Object {
            `$timestamp = `$_.Name.Split('_')[1]
            [datetime]::ParseExact(`$timestamp, 'ddMMyyyy.HHmmss', `$null)
        } -Descending

    if (`$folders.Count -gt 1) {
        `$rollbackFolder = `$folders[1].FullName
        Set-ItemProperty -Path "IIS:\Sites\Default Web Site\`$WebApplicationName" -Name physicalPath -Value `$rollbackFolder
        Write-Host "Rolled back to: `$rollbackFolder"
    } else {
        Write-Host 'No rollback folder found.'
    }
}
"@
            }
        }
        $phase.workflowTasks += $healthCheckTask
    }

    # Update approvals - Fixed version
    foreach ($approvalType in @('preDeployApprovals', 'postDeployApprovals')) {
        if ($null -eq $prodStage.$approvalType) {
            $prodStage | Add-Member -MemberType NoteProperty -Name $approvalType -Value @{
                approvals = @()
                approvalOptions = @{
                    requiredApproverCount = 1
                    releaseCreatorCanBeApprover = $false
                }
            }
        }

        if ($null -eq $prodStage.$approvalType.approvals -or $prodStage.$approvalType.approvals.Count -eq 0) {
            $prodStage.$approvalType.approvals = @(
                @{
                    rank = 1
                    isAutomated = $true
                    isNotificationOn = $false
                    approver = @{
                        id = $ApprovalGroupId
                        displayName = "PROD Approval Group"
                        isGroup = $true
                    }
                }
            )
        } else {
            foreach ($approval in $prodStage.$approvalType.approvals) {
                if (-not $approval.PSObject.Properties['approver']) {
                    $approval | Add-Member -MemberType NoteProperty -Name 'approver' -Value @{
                        id = $ApprovalGroupId
                        displayName = "PROD Approval Group"
                        isGroup = $true
                    }
                } else {
                    $approval.approver = @{
                        id = $ApprovalGroupId
                        displayName = "PROD Approval Group"
                        isGroup = $true
                    }
                }
            }
        }
    }

    # Set dependency on pre-prod
    $prodStage.conditions = @(
        @{
            conditionType = "environmentState"
            name = "pre-prod"
            value = "succeeded"
        }
    )

    # Add the new stage
    $pipeline.environments += $prodStage

    # Re-rank all environments
    for ($i = 0; $i -lt $pipeline.environments.Count; $i++) {
        $pipeline.environments[$i].rank = $i + 1
    }

    # Prepare the final payload
    $jsonBody = $pipeline | ConvertTo-Json -Depth 20
    $jsonBody | Out-File "modified_pipeline_$PipelineId.json"
    Write-Host "Saved modified pipeline definition to modified_pipeline_$PipelineId.json"

    # Update the pipeline
    try {
        $response = Invoke-RestMethod -Uri $url -Headers $Headers -Method Put -Body $jsonBody
        Write-Host "Successfully updated pipeline $PipelineId with PROD stage"
    } catch {
        Write-Host "Failed to update pipeline $PipelineId"
        Write-Host "Error details: $($_.Exception.Message)"
        if ($_.ErrorDetails) {
            Write-Host "Response: $($_.ErrorDetails.Message)"
        }
        exit 1
    }
}

# Process all pipelines
foreach ($PipelineId in $PipelineIds) {
    Add-ProdStage -PipelineId $PipelineId
}


# Add health check task (using standard PowerShell task)
$healthCheckTask = @{
    taskId      = "e213ff0f-5d5c-4791-802d-52ea3e7be1f1"  # PowerShell task GUID
    version     = "2.*"
    name        = "HealthCheckAndRollback"
    enabled     = $true
    inputs      = @{
        targetType  = "inline"
        script      = @"
# Force TLS 1.2
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

try {
    `$response = Invoke-WebRequest -Uri 'https://app-001-funtions-test/api/health' -UseBasicParsing -ErrorAction Stop
    if (`$response.StatusCode -ne 200) {
        Write-Host 'Health check failed. Initiating rollback...'
        `$DeploymentRoot = '$($ServerConfig.DeploymentRoot)'
        `$WebApplicationName = '$($ServerConfig.WebApplicationName)'

        `$folders = Get-ChildItem -Path `$DeploymentRoot -Directory |
            Where-Object { `$_.Name -match '^\d+(\.\d+)*_\d{8}\.\d{6}$' } |
            Sort-Object {
                `$timestamp = `$_.Name.Split('_')[1]
                [datetime]::ParseExact(`$timestamp, 'ddMMyyyy.HHmmss', `$null)
            } -Descending

        if (`$folders.Count -gt 1) {
            `$rollbackFolder = `$folders[1].FullName
            Set-ItemProperty -Path "IIS:\Sites\Default Web Site\`$WebApplicationName" -Name physicalPath -Value `$rollbackFolder
            Write-Host "Rolled back to: `$rollbackFolder"
        } else {
            Write-Host 'No rollback folder found.'
        }
        exit 1
    }
    Write-Host 'Health check passed'
    exit 0
} catch {
    Write-Host "Health check error: `$($_.Exception.Message)"
    exit 1
}
"@
    }
}


---------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Update approvals - Simplified and enforced to one group
foreach ($approvalType in @('preDeployApprovals', 'postDeployApprovals')) {
    # Ensure the approval block exists
    if ($null -eq $prodStage.$approvalType) {
        $prodStage | Add-Member -MemberType NoteProperty -Name $approvalType -Value @{}
    }

    # Set exactly one approval group
    $prodStage.$approvalType.approvals = @(
        @{
            rank = 1
            isAutomated = ($approvalType -eq 'postDeployApprovals')  # true for post, false for pre
            isNotificationOn = $true
            approver = @{
                id = $ApprovalGroupId
                displayName = "PROD Approval Group"
                isGroup = $true
            }
        }
    )

    # Set approval options
    $prodStage.$approvalType.approvalOptions = @{
        requiredApproverCount = 1
        releaseCreatorCanBeApprover = $false
        autoTriggeredAndPreviousEnvironmentApprovedCanBeSkipped = $false
        enforceIdentityRevalidation = $false
        timeoutInMinutes = 0
        executionOrder = if ($approvalType -eq 'preDeployApprovals') { "beforeGates" } else { "afterSuccessfulGates" }
    }
}
-------------------------------------------------------------------------------------------------------------------------------------

$healthCheckTask = @{
    taskId      = "e213ff0f-5d5c-4791-802d-52ea3e7be1f1"  # PowerShell task GUID
    version     = "2.*"
    name        = "HealthCheckAndRollback"
    enabled     = $true
    inputs      = @{
        targetType  = "inline"
        script      = @"
# Force TLS 1.2
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

# Debug: Print deployment config
Write-Host "=== Deployment Configuration ==="
Write-Host "DeploymentRoot: '$($ServerConfig.DeploymentRoot)'"
Write-Host "WebApplicationName: '$($ServerConfig.WebApplicationName)'"
Write-Host "==============================="

try {
    # Debug: Print health check URL
    Write-Host "Calling health endpoint: 'https://app-001-funtions-test/api/health'"
    
    `$response = Invoke-WebRequest -Uri 'https://app-001-funtions-test/api/health' -UseBasicParsing -ErrorAction Stop
    
    if (`$response.StatusCode -ne 200) {
        Write-Host "Health check failed (Status: `$(`$response.StatusCode)). Initiating rollback..."
        
        `$DeploymentRoot = '$($ServerConfig.DeploymentRoot)'
        `$WebApplicationName = '$($ServerConfig.WebApplicationName)'
        `$websitePath = "IIS:\Sites\Default Web Site\`$WebApplicationName"
        
        # Debug: Print current website path before rollback
        `$currentPath = (Get-ItemProperty -Path `$websitePath).physicalPath
        Write-Host "Current website path: `$currentPath"
        
        `$folders = Get-ChildItem -Path `$DeploymentRoot -Directory |
            Where-Object { `$_.Name -match '^\d+(\.\d+)*_\d{8}\.\d{6}$' } |
            Sort-Object {
                `$timestamp = `$_.Name.Split('_')[1]
                [datetime]::ParseExact(`$timestamp, 'ddMMyyyy.HHmmss', `$null)
            } -Descending

        if (`$folders.Count -gt 1) {
            `$rollbackFolder = `$folders[1].FullName
            Write-Host "Found rollback folder: `$rollbackFolder"
            
            Set-ItemProperty -Path `$websitePath -Name physicalPath -Value `$rollbackFolder
            
            # Debug: Verify new path
            `$newPath = (Get-ItemProperty -Path `$websitePath).physicalPath
            Write-Host "Rollback successful. New website path: `$newPath"
        } else {
            Write-Host 'No rollback folder found. Cannot rollback.'
        }
        exit 1
    }
    Write-Host '✅ Health check passed (Status: 200)'
    exit 0
} catch {
    Write-Host "❌ Health check error: $($_.Exception.Message)"
    Write-Host "Error details: $($_.ScriptStackTrace)"  # Debug: Print stack trace
    exit 1
}
"@
    }
}
--------------------------------------------------------------------------------------------------------------------


# Force TLS 1.2
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

$servers = '$($ServerConfig.Servers)' -split ','

$DeploymentRoot = '$($ServerConfig.DeploymentRoot)'
$WebApplicationName = '$($ServerConfig.WebApplicationName)'

# Optional: Set credentials for remote connection
# Comment this block if using integrated authentication
$Username = '$($ServerConfig.CredUsername)'  # Optional
$Password = ConvertTo-SecureString '$($ServerConfig.CredPassword)' -AsPlainText -Force
$Credential = New-Object System.Management.Automation.PSCredential ($Username, $Password)

$failed = $false

foreach ($server in $servers) {
    try {
        Write-Host "Connecting to $server for health check..."

        $healthCheckResult = Invoke-Command -ComputerName $server -Credential $Credential -ScriptBlock {
            try {
                $url = "http://localhost/api/health"
                $resp = Invoke-WebRequest -Uri $url -UseBasicParsing -TimeoutSec 10 -ErrorAction Stop
                if ($resp.StatusCode -eq 200) {
                    Write-Host "Health check passed on $env:COMPUTERNAME"
                    return $true
                } else {
                    Write-Host "Health check failed with status: $($resp.StatusCode)"
                    return $false
                }
            } catch {
                Write-Host "Error checking health: $($_.Exception.Message)"
                return $false
            }
        }

        if (-not $healthCheckResult) {
            Write-Host "Health check failed on $server"
            $failed = $true
            break
        }
    } catch {
        Write-Host "Could not connect to $server: $($_.Exception.Message)"
        $failed = $true
        break
    }
}

if ($failed) {
    Write-Host "Initiating rollback..."

    $folders = Get-ChildItem -Path $DeploymentRoot -Directory |
        Where-Object { $_.Name -match '^\d+(\.\d+)*_\d{8}\.\d{6}$' } |
        Sort-Object {
            $timestamp = $_.Name.Split('_')[1]
            [datetime]::ParseExact($timestamp, 'ddMMyyyy.HHmmss', $null)
        } -Descending

    if ($folders.Count -gt 1) {
        $rollbackFolder = $folders[1].FullName
        Set-ItemProperty -Path "IIS:\Sites\$WebApplicationName" -Name physicalPath -Value $rollbackFolder
        Write-Host "Rolled back to: $rollbackFolder"
    } else {
        Write-Host "No rollback folder found."
    }
    exit 1
} else {
    Write-Host "All health checks passed. Proceeding..."
    exit 0
}
-----------------------------------------------------------------------------------------

$healthCheckTask = @{
    taskId = "c7a3c3e7-660d-4964-b650-b1be5f4e6f79"  # PowerShell on Remote Machine task GUID
    version = "3.*"  # You may need to adjust based on your environment
    name = "HealthCheckAndRollback_PROD"
    enabled = $true
    inputs = @{
        Machines = "CHEAAPIDV03,CHEAAPIDV04"
        AdminUserName = "LEDGER\SVC-AUTODEPD01"
        AdminPassword = "409598359eriogseu90weu9jiogseu90ehuierio"
        protocol = "WinRM"
        Target = "inline"
        ScriptArguments = ""
        Script = @"
            [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

            \$DeploymentRoot = "C:\Releases\PreproductionPreProdApi.SystemConfiguration"
            \$WebApplicationName = "MyWebApp"

            \$failed = \$false

            \$url = "https://preprodapiredemptions.blemain.local/api/health"

            try {
                Write-Host "Running health check on host: \$env:COMPUTERNAME"
                \$resp = Invoke-WebRequest -Uri \$url -UseBasicParsing -TimeoutSec 10 -ErrorAction Stop
                if (\$resp.StatusCode -eq 200) {
                    Write-Host "Health check passed on \$env:COMPUTERNAME"
                } else {
                    Write-Host "Health check failed with status: \$([int]\$resp.StatusCode)"
                    \$failed = \$true
                }
            } catch {
                Write-Host "Health check error: \$($_.Exception.Message)"
                \$failed = \$true
            }

            if (\$failed) {
                Write-Host "Initiating rollback on \$env:COMPUTERNAME..."

                \$folders = Get-ChildItem -Path \$DeploymentRoot -Directory |
                    Where-Object { \$_ -and \$_.Name -match '^\d+(\.\d+)*_\d{8}\.\d{6}$' } |
                    Sort-Object {
                        \$timestamp = \$_.Name.Split('_')[1]
                        [datetime]::ParseExact(\$timestamp, 'ddMMyyyy.HHmmss', \$null)
                    } -Descending

                if (\$folders.Count -gt 1) {
                    \$rollbackFolder = \$folders[1].FullName
                    Set-ItemProperty -Path "IIS:\Sites\${WebApplicationName}" -Name physicalPath -Value \$rollbackFolder
                    Write-Host "Rolled back to: \$rollbackFolder"
                } else {
                    Write-Host "No rollback folder found."
                }
                exit 1
            } else {
                Write-Host "All health checks passed on \$env:COMPUTERNAME"
                exit 0
            }
"@
    }
}


-----------------------------------------------------------------------------------------------------------
$healthCheckTask = @{
    name = "RunHealthCheck_PROD"
    taskId = "d4c48ab2-58f6-4efb-8139-af3f3f6f3df0"  # GUID of PowerShellOnTargetMachines
    version = "3.*"
    enabled = $true
    inputs = @{
        Machines = "CHEAAPIDV03,CHEAAPIDV04"
        AdminUserName = "LEDGER\SVC-AUTODEPD01"
        AdminPassword = "409598359eriogseu90weu9jiogseu90ehuierio"
        Target = "InlineScript"
        Protocol = "Http"
        ScriptArguments = ""
        InlineScript = @'
            Write-Host "Running health check on $env:COMPUTERNAME"
            $url = "http://localhost/api/health"
            try {
                $resp = Invoke-WebRequest -Uri $url -UseBasicParsing -TimeoutSec 10 -ErrorAction Stop
                if ($resp.StatusCode -eq 200) {
                    Write-Host "Health check passed on $env:COMPUTERNAME"
                    exit 0
                } else {
                    Write-Host "Health check failed with status: $($resp.StatusCode)"
                    exit 1
                }
            } catch {
                Write-Host "Health check failed: $($_.Exception.Message)"
                exit 1
            }
        '@
    }
}

-------------------------------------------------------------------------------------------------------------
# Add health check task (corrected version)
$healthCheckTask = @{
    taskId      = "d8b84920-e1a5-44d7-811a-60afc0a5d0d0"  # GUID for PowerShellOnTargetMachines task
    version     = "3.*"
    name        = "HealthCheckAndRollback_PROD"
    enabled     = $true
    inputs      = @{
        Machines             = "CHEAAPIDV03,CHEAAPIDV04"
        AdminLogin           = "LEDGER\SVC-AUTODEPD01"
        AdminPassword        = "$(AdminPassword)"  # Reference a pipeline variable instead of hardcoding
        Protocol            = "Http"
        ScriptType          = "InlineScript"
        InlineScript        = @'
# Health check script
Write-Host "Running health check on $env:COMPUTERNAME"
$url = "http://localhost/api/health"
try {
    $resp = Invoke-WebRequest -Uri $url -UseBasicParsing -TimeoutSec 10 -ErrorAction Stop
    if ($resp.StatusCode -eq 200) {
        Write-Host "Health check passed on $env:COMPUTERNAME"
        exit 0
    } else {
        Write-Host "Health check failed with status: $($resp.StatusCode)"
        exit 1
    }
} catch {
    Write-Host "Health check failed: $($_.Exception.Message)"
    exit 1
}
'@
        RunPowershellInParallel = "false"
    }
}
-------------------------------------------------------------------------------
d4c48ab2-58f6-4efb-8139-af3f3f6f3df0
---------------------------------------------

- task: PowerShellOnTargetMachines@3
  inputs:
    Machines: 'CHEAAPIDV03,CHEAAPIDV04'
    AdminUserName: '$(adminUsername)'
    AdminPassword: '$(adminPassword)'
    Target: 'InlineScript'
    Protocol: 'Http'
    InlineScript: |
      Write-Host "Running health check on $env:COMPUTERNAME"
      $url = "http://localhost/api/health"
      $resp = Invoke-WebRequest -Uri $url -UseBasicParsing -TimeoutSec 10 -ErrorAction Stop
      if ($resp.StatusCode -eq 200) {
          Write-Host "Health check passed"
      } else {
          Write-Error "Health check failed with status: $($resp.StatusCode)"
      }
      ---------------------------------------
<#
.SYNOPSIS
    Performs health checks and automatic rollback using configuration from Config.json
.DESCRIPTION
    This script:
    1. Reads configuration from Config.json
    2. Checks application health status across multiple servers
    3. Automatically rolls back if health checks fail
    4. Returns proper exit codes for pipeline integration
.PARAMETER ConfigPath
    Path to the Config.json file
#>

param(
    [Parameter(Mandatory=$true)]
    [string]$ConfigPath
)

# Enable TLS 1.2
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

try {
    # Load configuration
    $config = Get-Content $ConfigPath -Raw | ConvertFrom-Json
    Write-Host "Loaded configuration from $ConfigPath"

    # Initialize counters
    $global:overallSuccess = $true
    $global:anyRollbackAttempted = $false
    $timeoutSeconds = 15
    $idleTimeoutMs = 60000

    function Invoke-HealthCheck {
        param (
            [string]$server,
            [string]$healthCheckUrl,
            [System.Management.Automation.PSCredential]$cred
        )
        
        try {
            Write-Host "`n=== Health Check on $server ==="
            
            $session = New-PSSession -ComputerName $server -Credential $cred `
                      -SessionOption (New-PSSessionOption -IdleTimeout $idleTimeoutMs) -ErrorAction Stop
            
            try {
                $response = Invoke-Command -Session $session -ScriptBlock {
                    param($url, $timeout)
                    try {
                        Invoke-WebRequest -Uri $url -UseBasicParsing -TimeoutSec $timeout
                    }
                    catch {
                        @{ StatusCode = 500; StatusDescription = $_.Exception.Message }
                    }
                } -ArgumentList $healthCheckUrl, $timeoutSeconds
                
                if ($response.StatusCode -eq 200) {
                    Write-Host "[SUCCESS] Health check passed"
                    return $true
                }
                else {
                    Write-Host "[FAILURE] Health check failed (Status: $($response.StatusCode))"
                    Write-Host "Response: $($response.StatusDescription)"
                    return $false
                }
            }
            finally {
                if ($session) { Remove-PSSession $session -ErrorAction SilentlyContinue }
            }
        }
        catch {
            Write-Host "[ERROR] Connection failed: $($_.Exception.Message)"
            return $false
        }
    }

    function Invoke-Rollback {
        param (
            [string]$server,
            [string]$deploymentRoot,
            [string]$webApplicationName,
            [System.Management.Automation.PSCredential]$cred
        )
        
        try {
            Write-Host "`n=== Attempting Rollback on $server ==="
            
            $session = New-PSSession -ComputerName $server -Credential $cred `
                      -SessionOption (New-PSSessionOption -IdleTimeout $idleTimeoutMs) -ErrorAction Stop
            
            try {
                # Verify deployment root exists
                $deploymentRootExists = Invoke-Command -Session $session -ScriptBlock {
                    param($root) 
                    Test-Path $root
                } -ArgumentList $deploymentRoot

                if (-not $deploymentRootExists) {
                    Write-Host "[ERROR] Path does not exist: $deploymentRoot"
                    return $false
                }

                # Get deployment folders
                $folders = Invoke-Command -Session $session -ScriptBlock {
                    param($root)
                    Get-ChildItem -Path $root -Directory |
                    Where-Object { $_.Name -match "^\d+(\.\d+)*_\d{8}\.\d{6}$" } |
                    Sort-Object { [datetime]::ParseExact($_.Name.Split('_')[1], 'ddMMyyyy.HHmmss', $null) } -Descending
                } -ArgumentList $deploymentRoot

                if ($folders.Count -gt 1) {
                    $rollbackFolder = $folders[1].FullName
                    Write-Host "Found rollback candidate: $rollbackFolder"
                    
                    # Perform rollback
                    $rollbackResult = Invoke-Command -Session $session -ScriptBlock {
                        param($folder, $appName)
                        try {
                            if (-not (Get-Module WebAdministration -ErrorAction SilentlyContinue)) {
                                Import-Module WebAdministration
                            }
                            if (-not (Test-Path 'IIS:\')) {
                                New-PSDrive -Name IIS -PSProvider WebAdministration -Root 'MACHINE/WEBROOT/APPHOST' | Out-Null
                            }
                            
                            $sitePath = "IIS:\Sites\Default Web Site\$appName"
                            $currentPath = (Get-ItemProperty -Path $sitePath).physicalPath
                            
                            if ($currentPath -ne $folder) {
                                Set-ItemProperty -Path $sitePath -Name physicalPath -Value $folder
                                Write-Host "Rollback successful from $currentPath to $folder"
                                return $true
                            }
                            else {
                                Write-Host "Already pointing to rollback folder"
                                return $false
                            }
                        }
                        catch {
                            Write-Host "Rollback failed: $($_.Exception.Message)"
                            return $false
                        }
                    } -ArgumentList $rollbackFolder, $webApplicationName
                    
                    return $rollbackResult
                }
                else {
                    Write-Host "[ERROR] No rollback folder found"
                    return $false
                }
            }
            catch {
                Write-Host "[ERROR] Rollback execution failed: $($_.Exception.Message)"
                return $false
            }
            finally {
                if ($session) { Remove-PSSession $session -ErrorAction SilentlyContinue }
            }
        }
        catch {
            Write-Host "[ERROR] Connection failed: $($_.Exception.Message)"
            return $false
        }
    }

    # Main execution
    $securePassword = ConvertTo-SecureString $config.AdminPassword -AsPlainText -Force
    $cred = New-Object System.Management.Automation.PSCredential($config.AdminLogin, $securePassword)

    Write-Host "Starting health checks with configuration:"
    Write-Host ($config | ConvertTo-Json -Depth 3)

    foreach ($app in $config.applications) {
        Write-Host "`nProcessing application: $($app.name)"
        $appSuccess = $true
        $appRollbackAttempted = $false
        
        foreach ($server in $app.servers) {
            Write-Host "`n=== Server: $server ==="
            
            $healthStatus = Invoke-HealthCheck -server $server -healthCheckUrl $app.healthCheckUrl -cred $cred
            
            if (-not $healthStatus) {
                $appSuccess = $false
                $rollbackResult = Invoke-Rollback -server $server -deploymentRoot $app.deploymentRoot `
                    -webApplicationName $app.name -cred $cred
                
                if ($rollbackResult) {
                    $appRollbackAttempted = $true
                    $global:anyRollbackAttempted = $true
                }
            }
        }
        
        if ($appSuccess) {
            Write-Host "`n[RESULT] All checks passed for $($app.name)"
        }
        elseif ($appRollbackAttempted) {
            Write-Host "`n[RESULT] Rollback attempted for $($app.name)"
        }
        else {
            Write-Host "`n[RESULT] Rollback failed for $($app.name)"
        }
        
        if (-not $appSuccess) { $global:overallSuccess = $false }
    }
    
    if ($global:overallSuccess) {
        Write-Host "`n[FINAL RESULT] All applications healthy"
        exit 0
    }
    elseif ($global:anyRollbackAttempted) {
        Write-Host "`n[FINAL RESULT] Some rollbacks succeeded"
        exit 1
    }
    else {
        Write-Host "`n[FINAL RESULT] All rollbacks failed"
        exit 1
    }
}
catch {
    Write-Host "`n[CRITICAL ERROR] $($_.Exception.Message)"
    exit 1
}
---------------------------------------------------------------------------------------
- task: PowerShell@2
  displayName: 'Health Check and Rollback'
  inputs:
    filePath: '$(System.DefaultWorkingDirectory)/scripts/healthcheck_rollback.ps1'
    arguments: '-ConfigPath "$(System.DefaultWorkingDirectory)/Config.json"'
    failOnStderr: true
    pwsh: true
    --------------------------------------------------------------------------------
    function Clone-Stage {
    param(
        [object]$sourceStage,
        [string]$newName,
        [object]$config,
        [string]$approvalGroupId
    )

    $newStage = $sourceStage | ConvertTo-Json -Depth 15 | ConvertFrom-Json
    $newStage.PSObject.Properties.Remove('id')
    $newStage.name = $newName

    # Process all deploy phases
    foreach ($phase in $newStage.deployPhases) {
        $phase.PSObject.Properties.Remove('phaseId')
        
        # Create new array for enabled tasks only
        $enabledTasks = New-Object System.Collections.ArrayList
        
        foreach ($task in $phase.workflowTasks) {
            if ($task.enabled -eq $true) {
                $task.PSObject.Properties.Remove('id')
                Update-TaskConfiguration -task $task -config $config
                $null = $enabledTasks.Add($task)
                Write-Log "Included enabled task: $($task.name)" -level "INFO"
            }
            else {
                Write-Log "Removing disabled task: $($task.name)" -level "INFO"
            }
        }
        
        # Replace workflowTasks with only enabled tasks
        $phase.workflowTasks = $enabledTasks.ToArray()
    }

    # Initialize conditions if they don't exist
    if (-not $newStage.PSObject.Properties['conditions']) {
        $newStage | Add-Member -MemberType NoteProperty -Name 'conditions' -Value @()
    }

    # Set Pre-Prod success condition for the new PROD stage
    $newStage.conditions = @(
        @{
            conditionType = "environmentState"
            name = "Pre-Prod"  # Must match your Pre-Prod stage name exactly
            value = "succeeded"
        }
    )
    Write-Log "Set PROD stage condition: Requires Pre-Prod success" -level "INFO"

    # Configure approvals
    Set-StageApprovals -stage $newStage -approvalGroupId $approvalGroupId

    return $newStage
}
-----------------------------------------------------------------------------------------------------------
function Add-ProdStage {
    param([int]$pipelineId, [object]$config, [string]$approvalGroupId)

    try {
        $url = "$baseUrl/_apis/release/definitions/$pipelineId`?api-version=$ApiVersion"
        $pipeline = Invoke-RestMethod -Uri $url -Headers $headers -Method Get

        # Check if PROD stage exists
        if ($pipeline.environments.name -contains 'prod') {
            Write-Log "Pipeline $pipelineId already has PROD stage - skipping" -level "WARN"
            return $false
        }

        # Find PRE-PROD stage
        $preProdStage = $pipeline.environments | Where-Object { $_.name -eq 'Pre-Prod' }  # Case-sensitive match
        if (-not $preProdStage) {
            Write-Log "No Pre-Prod stage found in pipeline $pipelineId - skipping" -level "WARN"
            return $false
        }

        # Clone PRE-PROD to create PROD
        $prodStage = Clone-Stage -sourceStage $preProdStage -newName "Prod" -config $config -approvalGroupId $approvalGroupId

        # Insert PROD after PRE-PROD
        $environments = [System.Collections.ArrayList]@($pipeline.environments)
        $preProdIndex = $environments.IndexOf($preProdStage)
        $environments.Insert($preProdIndex + 1, $prodStage)

        # Update ranks
        for ($i = 0; $i -lt $environments.Count; $i++) {
            $environments[$i].rank = $i + 1
        }

        $pipeline.environments = $environments

        # Update the pipeline
        $updatedPipeline = Invoke-RestMethod -Uri $url -Headers $headers -Method Put `
            -Body ($pipeline | ConvertTo-Json -Depth 15)

        Write-Log "Successfully updated pipeline $pipelineId" -level "INFO"
        return $true
    }
    catch {
        Write-Log "ERROR processing pipeline $pipelineId : $($_.Exception.Message)" -level "ERROR"
        if ($_.ErrorDetails.Message) {
            Write-Log "Detailed error: $($_.ErrorDetails.Message)" -level "ERROR"
        }
        return $false
    }
}
-----------------------------------------------------------------------------------------------------------
<#
.SYNOPSIS
    Creates PROD stages with health checks, removing disabled tasks and setting approvals
.DESCRIPTION
    This script:
    1. Clones PRE-PROD stages to create PROD stages
    2. Removes disabled tasks
    3. Adds health check and rollback task
    4. Sets Pre-Prod success condition
    5. Configures approvals
#>

param(
    [string]$Org,
    [string]$Project,
    [string]$Pat,
    [string]$ApiVersion = "7.1-preview.4",
    [string]$PipelineIds,
    [string]$ConfigPath,
    [string]$ApprovalGroupId
)

# Set up authentication
$base64Auth = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(":$Pat"))
$headers = @{
    Authorization = "Basic $base64Auth"
    "Content-Type" = "application/json"
}

# Logging function
function Write-Log {
    param([string]$message, [string]$level = "INFO")
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $logEntry = "[$timestamp] [$level] $message"
    Write-Host $logEntry
    Add-Content -Path ".\DeploymentLog.log" -Value $logEntry
}

# Load configuration
try {
    $configData = Get-Content $ConfigPath -Raw | ConvertFrom-Json
    Write-Log "Loaded configuration file successfully" -level "DEBUG"
}
catch {
    Write-Log "Failed to load configuration: $_" -level "ERROR"
    exit 1
}

# Create config lookup with integer keys
$pipelineConfigs = @{}
foreach ($pipeline in $configData.Pipelines) {
    try {
        $id = [int]$pipeline.PipelineId
        $pipelineConfigs[$id] = $pipeline.Config
        Write-Log "Loaded config for Pipeline ID $id" -level "DEBUG"
    }
    catch {
        Write-Log "Invalid PipelineId in config: $($pipeline.PipelineId)" -level "ERROR"
    }
}

# Convert pipeline IDs to integers
[int[]]$PipelineIds = $PipelineIds -split ',' | ForEach-Object {
    try {
        $id = [int]$_.Trim()
        Write-Log "Processing Pipeline ID: $id" -level "DEBUG"
        $id
    }
    catch {
        Write-Log "Invalid Pipeline ID format: $_" -level "ERROR"
    }
}

$baseUrl = "https://vsrm.dev.azure.com/$Org/$Project"

function Update-TaskConfiguration {
    param(
        [object]$task,
        [object]$config
    )

    if (-not $task -or -not $task.inputs) {
        Write-Log "Task or inputs are null" -level "DEBUG"
        return
    }

    # List of parameters to update (case-insensitive)
    $parametersToUpdate = @{
        "ApiServer" = $config.ApiServer
        "DeploymentFolder" = $config.DeploymentFolder
        "DNSRepoName" = $config.DNSRepoName
        "AdminLogin" = $config.AdminLogin
        "AdminPassword" = $config.AdminPassword
    }

    Write-Log "Updating task: $($task.name)" -level "DEBUG"

    foreach ($param in $parametersToUpdate.Keys) {
        $matchingKey = $task.inputs.PSObject.Properties.Name | 
                      Where-Object { $_ -like $param } | 
                      Select-Object -First 1
        
        if ($matchingKey -and $parametersToUpdate[$param]) {
            $task.inputs.$matchingKey = $parametersToUpdate[$param]
            Write-Log "Updated input '$matchingKey' to '$($parametersToUpdate[$param])'" -level "INFO"
        }
    }

    if ($task.inputs.scriptArguments) {
        $argsString = $task.inputs.scriptArguments
        foreach ($param in $parametersToUpdate.Keys) {
            if ($parametersToUpdate[$param]) {
                $argsString = $argsString -replace "(-{1,2}$param)\s+""[^""]*""", "`$1 ""$($parametersToUpdate[$param])"""
            }
        }
        $task.inputs.scriptArguments = $argsString.Trim()
    }
}

function Add-HealthCheckTask {
    param(
        [object]$phase,
        [object]$config
    )

    $healthCheckTask = @{
        taskId = "e213ff0f-5d5c-4791-802d-52ea3e7be1f1"  # PowerShell@2 task
        version = "2.*"
        name = "HealthCheckAndRollback"
        enabled = $true
        inputs = @{
            targetType = "filePath"
            filePath = "$(System.DefaultWorkingDirectory)/scripts/healthcheck_rollback.ps1"
            arguments = "-ConfigPath `"$(System.DefaultWorkingDirectory)/Config.json`""
            pwsh = "true"
            failOnStderr = "true"
        }
    }

    # Add to beginning of phase tasks
    $phase.workflowTasks = @($healthCheckTask) + $phase.workflowTasks
    Write-Log "Added health check task to phase" -level "INFO"
}

function Set-StageApprovals {
    param(
        [object]$stage,
        [string]$approvalGroupId
    )

    foreach ($approvalType in @('preDeployApprovals', 'postDeployApprovals')) {
        if ($null -eq $stage.$approvalType) {
            $stage | Add-Member -MemberType NoteProperty -Name $approvalType -Value @{}
        }

        $stage.$approvalType.approvals = @(
            @{
                rank = 1
                isAutomated = ($approvalType -eq 'postDeployApprovals')
                isNotificationOn = $true
                approver = @{
                    id = $approvalGroupId
                    displayName = "PROD Approval Group"
                    isGroup = $true
                }
            }
        )

        $stage.$approvalType.approvalOptions = @{
            requiredApproverCount = 1
            releaseCreatorCanBeApprover = $false
            autoTriggeredAndPreviousEnvironmentApprovedCanBeSkipped = $false
            enforceIdentityRevalidation = $false
            timeoutInMinutes = 0
            executionOrder = if ($approvalType -eq 'preDeployApprovals') { "beforeGates" } else { "afterSuccessfulGates" }
        }
    }
}

function Clone-Stage {
    param(
        [object]$sourceStage,
        [string]$newName,
        [object]$config,
        [string]$approvalGroupId
    )

    $newStage = $sourceStage | ConvertTo-Json -Depth 15 | ConvertFrom-Json
    $newStage.PSObject.Properties.Remove('id')
    $newStage.name = $newName

    # Process all deploy phases
    foreach ($phase in $newStage.deployPhases) {
        $phase.PSObject.Properties.Remove('phaseId')
        
        # Create new array for enabled tasks only
        $enabledTasks = New-Object System.Collections.ArrayList
        
        foreach ($task in $phase.workflowTasks) {
            if ($task.enabled -eq $true) {
                $task.PSObject.Properties.Remove('id')
                Update-TaskConfiguration -task $task -config $config
                $null = $enabledTasks.Add($task)
                Write-Log "Included enabled task: $($task.name)" -level "INFO"
            }
            else {
                Write-Log "Removing disabled task: $($task.name)" -level "INFO"
            }
        }
        
        # Replace workflowTasks with only enabled tasks
        $phase.workflowTasks = $enabledTasks.ToArray()

        # Add health check task to the first phase only
        if ($phase.name -eq "Run on agent") {
            Add-HealthCheckTask -phase $phase -config $config
        }
    }

    # Initialize conditions if they don't exist
    if (-not $newStage.PSObject.Properties['conditions']) {
        $newStage | Add-Member -MemberType NoteProperty -Name 'conditions' -Value @()
    }

    # Set Pre-Prod success condition
    $newStage.conditions = @(
        @{
            conditionType = "environmentState"
            name = "Pre-Prod"  # Must match your Pre-Prod stage name exactly
            value = "succeeded"
        }
    )

    # Configure approvals
    Set-StageApprovals -stage $newStage -approvalGroupId $approvalGroupId

    return $newStage
}

function Add-ProdStage {
    param([int]$pipelineId, [object]$config, [string]$approvalGroupId)

    try {
        $url = "$baseUrl/_apis/release/definitions/$pipelineId`?api-version=$ApiVersion"
        $pipeline = Invoke-RestMethod -Uri $url -Headers $headers -Method Get

        # Check if PROD stage exists
        if ($pipeline.environments.name -contains 'prod') {
            Write-Log "Pipeline $pipelineId already has PROD stage - skipping" -level "WARN"
            return $false
        }

        # Find PRE-PROD stage
        $preProdStage = $pipeline.environments | Where-Object { $_.name -eq 'Pre-Prod' }
        if (-not $preProdStage) {
            Write-Log "No Pre-Prod stage found in pipeline $pipelineId - skipping" -level "WARN"
            return $false
        }

        # Clone PRE-PROD to create PROD
        $prodStage = Clone-Stage -sourceStage $preProdStage -newName "Prod" -config $config -approvalGroupId $approvalGroupId

        # Insert PROD after PRE-PROD
        $environments = [System.Collections.ArrayList]@($pipeline.environments)
        $preProdIndex = $environments.IndexOf($preProdStage)
        $environments.Insert($preProdIndex + 1, $prodStage)

        # Update ranks
        for ($i = 0; $i -lt $environments.Count; $i++) {
            $environments[$i].rank = $i + 1
        }

        $pipeline.environments = $environments

        # Update the pipeline
        $updatedPipeline = Invoke-RestMethod -Uri $url -Headers $headers -Method Put `
            -Body ($pipeline | ConvertTo-Json -Depth 15)

        Write-Log "Successfully updated pipeline $pipelineId with health check task" -level "INFO"
        return $true
    }
    catch {
        Write-Log "ERROR processing pipeline $pipelineId : $($_.Exception.Message)" -level "ERROR"
        if ($_.ErrorDetails.Message) {
            Write-Log "Detailed error: $($_.ErrorDetails.Message)" -level "ERROR"
        }
        return $false
    }
}

# Main execution
Write-Log "Starting PROD stage creation process with health checks"
$successCount = 0

foreach ($id in $PipelineIds) {
    if (-not $pipelineConfigs.ContainsKey($id)) {
        Write-Log "No configuration found for Pipeline ID $id" -level "ERROR"
        continue
    }
    
    $config = $pipelineConfigs[$id]
    
    if (Add-ProdStage -pipelineId $id -config $config -approvalGroupId $ApprovalGroupId) {
        $successCount++
    }
}

if ($successCount -eq $PipelineIds.Count) {
    Write-Log "All pipelines updated successfully with health check tasks" -level "INFO"
    exit 0
} else {
    Write-Log "Failed to update all pipelines (success: $successCount/$($PipelineIds.Count))" -level "ERROR"
    exit 1
}
==============================================================================================================================

<#
.SYNOPSIS
    Performs health checks and rollback based on pipeline configurations
.DESCRIPTION
    This script:
    1. Reads pipeline configurations from Config.json
    2. Performs health checks for each pipeline
    3. Automatically rolls back if health checks fail
#>

param(
    [Parameter(Mandatory=$true)]
    [string]$ConfigPath
)

# Enable TLS 1.2
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

try {
    # Load configuration with validation
    $config = Get-Content $ConfigPath -Raw | ConvertFrom-Json
    
    # Validate required fields
    $requiredFields = @('AdminLogin', 'AdminPassword', 'Pipelines')
    foreach ($field in $requiredFields) {
        if (-not $config.PSObject.Properties[$field]) {
            throw "Missing required field in config: $field"
        }
    }

    # Initialize counters
    $global:overallSuccess = $true
    $global:anyRollbackAttempted = $false
    $timeoutSeconds = 15
    $idleTimeoutMs = 60000

    # Create credentials
    $securePassword = ConvertTo-SecureString $config.AdminPassword -AsPlainText -Force
    $cred = New-Object System.Management.Automation.PSCredential($config.AdminLogin, $securePassword)

    Write-Host "Starting health checks with configuration:"
    Write-Host ($config | ConvertTo-Json -Depth 3)

    # Process each pipeline in the config
    foreach ($pipeline in $config.Pipelines) {
        Write-Host "`nProcessing Pipeline ID: $($pipeline.PipelineId)"
        $pipelineSuccess = $true
        $pipelineRollbackAttempted = $false
        
        foreach ($server in $pipeline.Config.servers) {
            Write-Host "`n=== Server: $server ==="
            
            $healthStatus = Invoke-HealthCheck -server $server -healthCheckUrl $pipeline.Config.healthCheckUrl -cred $cred
            
            if (-not $healthStatus) {
                $pipelineSuccess = $false
                $rollbackResult = Invoke-Rollback -server $server `
                    -deploymentRoot $pipeline.Config.deploymentRoot `
                    -webApplicationName $pipeline.Config.applicationName `
                    -cred $cred
                
                if ($rollbackResult) {
                    $pipelineRollbackAttempted = $true
                    $global:anyRollbackAttempted = $true
                }
            }
        }
        
        if ($pipelineSuccess) {
            Write-Host "`n[RESULT] All checks passed for Pipeline $($pipeline.PipelineId)"
        }
        elseif ($pipelineRollbackAttempted) {
            Write-Host "`n[RESULT] Rollback attempted for Pipeline $($pipeline.PipelineId)"
        }
        else {
            Write-Host "`n[RESULT] Rollback failed for Pipeline $($pipeline.PipelineId)"
        }
        
        if (-not $pipelineSuccess) { $global:overallSuccess = $false }
    }
    
    if ($global:overallSuccess) {
        Write-Host "`n[FINAL RESULT] All pipelines healthy"
        exit 0
    }
    elseif ($global:anyRollbackAttempted) {
        Write-Host "`n[FINAL RESULT] Some rollbacks succeeded"
        exit 1
    }
    else {
        Write-Host "`n[FINAL RESULT] All rollbacks failed"
        exit 1
    }
}
catch {
    Write-Host "`n[CRITICAL ERROR] $($_.Exception.Message)"
    exit 1
}

function Invoke-HealthCheck {
    param (
        [string]$server,
        [string]$healthCheckUrl,
        [System.Management.Automation.PSCredential]$cred
    )
    
    try {
        Write-Host "`n=== Health Check on $server ==="
        
        $session = New-PSSession -ComputerName $server -Credential $cred `
                  -SessionOption (New-PSSessionOption -IdleTimeout $idleTimeoutMs) -ErrorAction Stop
        
        try {
            $response = Invoke-Command -Session $session -ScriptBlock {
                param($url, $timeout)
                try {
                    Invoke-WebRequest -Uri $url -UseBasicParsing -TimeoutSec $timeout
                }
                catch {
                    @{ StatusCode = 500; StatusDescription = $_.Exception.Message }
                }
            } -ArgumentList $healthCheckUrl, $timeoutSeconds
            
            if ($response.StatusCode -eq 200) {
                Write-Host "[SUCCESS] Health check passed"
                return $true
            }
            else {
                Write-Host "[FAILURE] Health check failed (Status: $($response.StatusCode))"
                Write-Host "Response: $($response.StatusDescription)"
                return $false
            }
        }
        finally {
            if ($session) { Remove-PSSession $session -ErrorAction SilentlyContinue }
        }
    }
    catch {
        Write-Host "[ERROR] Connection failed: $($_.Exception.Message)"
        return $false
    }
}

function Invoke-Rollback {
    param (
        [string]$server,
        [string]$deploymentRoot,
        [string]$webApplicationName,
        [System.Management.Automation.PSCredential]$cred
    )
    
    try {
        Write-Host "`n=== Attempting Rollback on $server ==="
        
        $session = New-PSSession -ComputerName $server -Credential $cred `
                  -SessionOption (New-PSSessionOption -IdleTimeout $idleTimeoutMs) -ErrorAction Stop
        
        try {
            # Verify deployment root exists
            $deploymentRootExists = Invoke-Command -Session $session -ScriptBlock {
                param($root) 
                Test-Path $root
            } -ArgumentList $deploymentRoot

            if (-not $deploymentRootExists) {
                Write-Host "[ERROR] Path does not exist: $deploymentRoot"
                return $false
            }

            # Get deployment folders
            $folders = Invoke-Command -Session $session -ScriptBlock {
                param($root)
                Get-ChildItem -Path $root -Directory |
                Where-Object { $_.Name -match "^\d+(\.\d+)*_\d{8}\.\d{6}$" } |
                Sort-Object { [datetime]::ParseExact($_.Name.Split('_')[1], 'ddMMyyyy.HHmmss', $null) } -Descending
            } -ArgumentList $deploymentRoot

            if ($folders.Count -gt 1) {
                $rollbackFolder = $folders[1].FullName
                Write-Host "Found rollback candidate: $rollbackFolder"
                
                # Perform rollback
                $rollbackResult = Invoke-Command -Session $session -ScriptBlock {
                    param($folder, $appName)
                    try {
                        if (-not (Get-Module WebAdministration -ErrorAction SilentlyContinue)) {
                            Import-Module WebAdministration
                        }
                        if (-not (Test-Path 'IIS:\')) {
                            New-PSDrive -Name IIS -PSProvider WebAdministration -Root 'MACHINE/WEBROOT/APPHOST' | Out-Null
                        }
                        
                        $sitePath = "IIS:\Sites\Default Web Site\$appName"
                        $currentPath = (Get-ItemProperty -Path $sitePath).physicalPath
                        
                        if ($currentPath -ne $folder) {
                            Set-ItemProperty -Path $sitePath -Name physicalPath -Value $folder
                            Write-Host "Rollback successful from $currentPath to $folder"
                            return $true
                        }
                        else {
                            Write-Host "Already pointing to rollback folder"
                            return $false
                        }
                    }
                    catch {
                        Write-Host "Rollback failed: $($_.Exception.Message)"
                        return $false
                    }
                } -ArgumentList $rollbackFolder, $webApplicationName
                
                return $rollbackResult
            }
            else {
                Write-Host "[ERROR] No rollback folder found"
                return $false
            }
        }
        catch {
            Write-Host "[ERROR] Rollback execution failed: $($_.Exception.Message)"
            return $false
        }
        finally {
            if ($session) { Remove-PSSession $session -ErrorAction SilentlyContinue }
        }
    }
    catch {
        Write-Host "[ERROR] Connection failed: $($_.Exception.Message)"
        return $false
    }
}
________________________________________________________________________________________________
$servers = @(
    $(([string]$ApiServer -split ',') | 
      ForEach-Object { 
          if (-not [string]::IsNullOrWhiteSpace($_)) { 
              "    '$($_.Trim() -replace "'","''")'" 
          }
      } | 
      Join-String -Separator ",`n")
)
$DeploymentRoot = '$($DeploymentRoot1 -replace "'","''")'
$WebApplicationName = '$($webApplicationName -replace "'","''")'
$healthcheckUrl = '$($healthcheckUrl1 -replace "'","''")'
$timeoutSeconds = 15

# Debug output
Write-Host "=== Configuration ==="
Write-Host "Servers: $($servers -join ', ')"
Write-Host "Deployment Root: $DeploymentRoot"
Write-Host "Web Application: $WebApplicationName"
Write-Host "Healthcheck URL: $healthcheckUrl"
===========================================================================================
