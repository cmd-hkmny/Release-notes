param(
    [string]$Org,
    [string]$Project,
    [string]$Pat,
    [string]$ApiVersion = "7.1-preview.4",
    [string]$PipelineIds,
    [string]$ConfigPath,
    [string]$ApprovalGroupId
)

# Convert pipeline IDs to integers with validation
$PipelineIds = $PipelineIds -split "," | Where-Object {
    $_.Trim() -match '^\d+$'
} | ForEach-Object {
    [int]$_.Trim()
}

if (-not $PipelineIds -or $PipelineIds.Count -eq 0) {
    Write-Error "No valid numeric Pipeline IDs found. Please check the input."
    exit 1
}

# Set up authentication headers
$AuthHeader = "Basic " + [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(":$Pat"))
$Headers = @{
    "Authorization" = $AuthHeader
    "Content-Type"  = "application/json"
    "Accept"        = "application/json; api-version=$ApiVersion"
}

# Load server configuration
if ($ConfigPath -match "\.json$") {
    $ServerConfig = Get-Content -Path $ConfigPath | ConvertFrom-Json
} elseif ($ConfigPath -match "\.csv$") {
    $ServerConfig = Import-Csv -Path $ConfigPath | Select-Object -First 1
} else {
    Write-Host "Unsupported config format. Use JSON or CSV."
    exit 1
}

Function Add-ProdStage {
    param ([int]$PipelineId)

    Write-Host "`nProcessing Pipeline ID: $PipelineId"

    $url = "https://vsrm.dev.azure.com/$Org/$Project/_apis/release/definitions/${PipelineId}?api-version=$ApiVersion"
    
    try {
        # Get the existing pipeline definition
        $pipeline = Invoke-RestMethod -Uri $url -Headers $Headers -Method Get
        
        # Save original for debugging
        $pipeline | ConvertTo-Json -Depth 20 | Out-File "original_pipeline_$PipelineId.json"
        Write-Host "Saved original pipeline definition to original_pipeline_$PipelineId.json"
    } catch {
        Write-Host "ERROR fetching pipeline ID: $PipelineId. $_"
        return
    }

    # Check for pre-prod stage
    $preProdStage = $pipeline.environments | Where-Object { $_.name -eq 'pre-prod' } | Select-Object -First 1
    if (-not $preProdStage) {
        Write-Host "No pre-prod stage found in pipeline $PipelineId"
        return
    }

    # Check if prod already exists
    if ($pipeline.environments.name -contains 'prod') {
        Write-Host "PROD stage already exists in pipeline $PipelineId"
        return
    }

    # Clone the pre-prod stage
    $prodStage = $preProdStage | ConvertTo-Json -Depth 20 | ConvertFrom-Json

    # Clean up IDs and set new properties
    $prodStage.PSObject.Properties.Remove('id')
    $prodStage.name = "prod"
    $prodStage.rank = $pipeline.environments.Count + 1

    # Process deployment phases
    foreach ($phase in $prodStage.deployPhases) {
        $phase.PSObject.Properties.Remove('phaseId')
        
        # Clean task IDs
        foreach ($task in $phase.workflowTasks) {
            $task.PSObject.Properties.Remove('id')
        }

        # Add health check task (using standard PowerShell task)
        $healthCheckTask = @{
            taskId      = "e213ff0f-5d5c-4791-802d-52ea3e7be1f1"  # PowerShell task GUID
            version     = "2.*"
            name        = "HealthCheckAndRollback"
            enabled     = $true
            inputs      = @{
                targetType  = "inline"
                script      = @"
`$response = Invoke-WebRequest -Uri 'https://app-001-funtions-test/api/health' -UseBasicParsing
if (`$response.StatusCode -ne 200) {
    Write-Host 'Health check failed. Initiating rollback...'
    `$DeploymentRoot = '$($ServerConfig.DeploymentRoot)'
    `$WebApplicationName = '$($ServerConfig.WebApplicationName)'

    `$folders = Get-ChildItem -Path `$DeploymentRoot -Directory |
        Where-Object { `$_.Name -match '^\d+(\.\d+)*_\d{8}\.\d{6}$' } |
        Sort-Object {
            `$timestamp = `$_.Name.Split('_')[1]
            [datetime]::ParseExact(`$timestamp, 'ddMMyyyy.HHmmss', `$null)
        } -Descending

    if (`$folders.Count -gt 1) {
        `$rollbackFolder = `$folders[1].FullName
        Set-ItemProperty -Path "IIS:\Sites\Default Web Site\`$WebApplicationName" -Name physicalPath -Value `$rollbackFolder
        Write-Host "Rolled back to: `$rollbackFolder"
    } else {
        Write-Host 'No rollback folder found.'
    }
}
"@
            }
        }
        $phase.workflowTasks += $healthCheckTask
    }

    # Update approvals - Fixed version
    foreach ($approvalType in @('preDeployApprovals', 'postDeployApprovals')) {
        if ($null -eq $prodStage.$approvalType) {
            $prodStage | Add-Member -MemberType NoteProperty -Name $approvalType -Value @{
                approvals = @()
                approvalOptions = @{
                    requiredApproverCount = 1
                    releaseCreatorCanBeApprover = $false
                }
            }
        }

        if ($null -eq $prodStage.$approvalType.approvals -or $prodStage.$approvalType.approvals.Count -eq 0) {
            $prodStage.$approvalType.approvals = @(
                @{
                    rank = 1
                    isAutomated = $true
                    isNotificationOn = $false
                    approver = @{
                        id = $ApprovalGroupId
                        displayName = "PROD Approval Group"
                        isGroup = $true
                    }
                }
            )
        } else {
            foreach ($approval in $prodStage.$approvalType.approvals) {
                if (-not $approval.PSObject.Properties['approver']) {
                    $approval | Add-Member -MemberType NoteProperty -Name 'approver' -Value @{
                        id = $ApprovalGroupId
                        displayName = "PROD Approval Group"
                        isGroup = $true
                    }
                } else {
                    $approval.approver = @{
                        id = $ApprovalGroupId
                        displayName = "PROD Approval Group"
                        isGroup = $true
                    }
                }
            }
        }
    }

    # Set dependency on pre-prod
    $prodStage.conditions = @(
        @{
            conditionType = "environmentState"
            name = "pre-prod"
            value = "succeeded"
        }
    )

    # Add the new stage
    $pipeline.environments += $prodStage

    # Re-rank all environments
    for ($i = 0; $i -lt $pipeline.environments.Count; $i++) {
        $pipeline.environments[$i].rank = $i + 1
    }

    # Prepare the final payload
    $jsonBody = $pipeline | ConvertTo-Json -Depth 20
    $jsonBody | Out-File "modified_pipeline_$PipelineId.json"
    Write-Host "Saved modified pipeline definition to modified_pipeline_$PipelineId.json"

    # Update the pipeline
    try {
        $response = Invoke-RestMethod -Uri $url -Headers $Headers -Method Put -Body $jsonBody
        Write-Host "Successfully updated pipeline $PipelineId with PROD stage"
    } catch {
        Write-Host "Failed to update pipeline $PipelineId"
        Write-Host "Error details: $($_.Exception.Message)"
        if ($_.ErrorDetails) {
            Write-Host "Response: $($_.ErrorDetails.Message)"
        }
        exit 1
    }
}

# Process all pipelines
foreach ($PipelineId in $PipelineIds) {
    Add-ProdStage -PipelineId $PipelineId
}


# Add health check task (using standard PowerShell task)
$healthCheckTask = @{
    taskId      = "e213ff0f-5d5c-4791-802d-52ea3e7be1f1"  # PowerShell task GUID
    version     = "2.*"
    name        = "HealthCheckAndRollback"
    enabled     = $true
    inputs      = @{
        targetType  = "inline"
        script      = @"
# Force TLS 1.2
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

try {
    `$response = Invoke-WebRequest -Uri 'https://app-001-funtions-test/api/health' -UseBasicParsing -ErrorAction Stop
    if (`$response.StatusCode -ne 200) {
        Write-Host 'Health check failed. Initiating rollback...'
        `$DeploymentRoot = '$($ServerConfig.DeploymentRoot)'
        `$WebApplicationName = '$($ServerConfig.WebApplicationName)'

        `$folders = Get-ChildItem -Path `$DeploymentRoot -Directory |
            Where-Object { `$_.Name -match '^\d+(\.\d+)*_\d{8}\.\d{6}$' } |
            Sort-Object {
                `$timestamp = `$_.Name.Split('_')[1]
                [datetime]::ParseExact(`$timestamp, 'ddMMyyyy.HHmmss', `$null)
            } -Descending

        if (`$folders.Count -gt 1) {
            `$rollbackFolder = `$folders[1].FullName
            Set-ItemProperty -Path "IIS:\Sites\Default Web Site\`$WebApplicationName" -Name physicalPath -Value `$rollbackFolder
            Write-Host "Rolled back to: `$rollbackFolder"
        } else {
            Write-Host 'No rollback folder found.'
        }
        exit 1
    }
    Write-Host 'Health check passed'
    exit 0
} catch {
    Write-Host "Health check error: `$($_.Exception.Message)"
    exit 1
}
"@
    }
}


---------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Update approvals - Simplified and enforced to one group
foreach ($approvalType in @('preDeployApprovals', 'postDeployApprovals')) {
    # Ensure the approval block exists
    if ($null -eq $prodStage.$approvalType) {
        $prodStage | Add-Member -MemberType NoteProperty -Name $approvalType -Value @{}
    }

    # Set exactly one approval group
    $prodStage.$approvalType.approvals = @(
        @{
            rank = 1
            isAutomated = ($approvalType -eq 'postDeployApprovals')  # true for post, false for pre
            isNotificationOn = $true
            approver = @{
                id = $ApprovalGroupId
                displayName = "PROD Approval Group"
                isGroup = $true
            }
        }
    )

    # Set approval options
    $prodStage.$approvalType.approvalOptions = @{
        requiredApproverCount = 1
        releaseCreatorCanBeApprover = $false
        autoTriggeredAndPreviousEnvironmentApprovedCanBeSkipped = $false
        enforceIdentityRevalidation = $false
        timeoutInMinutes = 0
        executionOrder = if ($approvalType -eq 'preDeployApprovals') { "beforeGates" } else { "afterSuccessfulGates" }
    }
}
-------------------------------------------------------------------------------------------------------------------------------------

$healthCheckTask = @{
    taskId      = "e213ff0f-5d5c-4791-802d-52ea3e7be1f1"  # PowerShell task GUID
    version     = "2.*"
    name        = "HealthCheckAndRollback"
    enabled     = $true
    inputs      = @{
        targetType  = "inline"
        script      = @"
# Force TLS 1.2
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

# Debug: Print deployment config
Write-Host "=== Deployment Configuration ==="
Write-Host "DeploymentRoot: '$($ServerConfig.DeploymentRoot)'"
Write-Host "WebApplicationName: '$($ServerConfig.WebApplicationName)'"
Write-Host "==============================="

try {
    # Debug: Print health check URL
    Write-Host "Calling health endpoint: 'https://app-001-funtions-test/api/health'"
    
    `$response = Invoke-WebRequest -Uri 'https://app-001-funtions-test/api/health' -UseBasicParsing -ErrorAction Stop
    
    if (`$response.StatusCode -ne 200) {
        Write-Host "Health check failed (Status: `$(`$response.StatusCode)). Initiating rollback..."
        
        `$DeploymentRoot = '$($ServerConfig.DeploymentRoot)'
        `$WebApplicationName = '$($ServerConfig.WebApplicationName)'
        `$websitePath = "IIS:\Sites\Default Web Site\`$WebApplicationName"
        
        # Debug: Print current website path before rollback
        `$currentPath = (Get-ItemProperty -Path `$websitePath).physicalPath
        Write-Host "Current website path: `$currentPath"
        
        `$folders = Get-ChildItem -Path `$DeploymentRoot -Directory |
            Where-Object { `$_.Name -match '^\d+(\.\d+)*_\d{8}\.\d{6}$' } |
            Sort-Object {
                `$timestamp = `$_.Name.Split('_')[1]
                [datetime]::ParseExact(`$timestamp, 'ddMMyyyy.HHmmss', `$null)
            } -Descending

        if (`$folders.Count -gt 1) {
            `$rollbackFolder = `$folders[1].FullName
            Write-Host "Found rollback folder: `$rollbackFolder"
            
            Set-ItemProperty -Path `$websitePath -Name physicalPath -Value `$rollbackFolder
            
            # Debug: Verify new path
            `$newPath = (Get-ItemProperty -Path `$websitePath).physicalPath
            Write-Host "Rollback successful. New website path: `$newPath"
        } else {
            Write-Host 'No rollback folder found. Cannot rollback.'
        }
        exit 1
    }
    Write-Host '✅ Health check passed (Status: 200)'
    exit 0
} catch {
    Write-Host "❌ Health check error: $($_.Exception.Message)"
    Write-Host "Error details: $($_.ScriptStackTrace)"  # Debug: Print stack trace
    exit 1
}
"@
    }
}
--------------------------------------------------------------------------------------------------------------------


# Force TLS 1.2
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

$servers = '$($ServerConfig.Servers)' -split ','

$DeploymentRoot = '$($ServerConfig.DeploymentRoot)'
$WebApplicationName = '$($ServerConfig.WebApplicationName)'

# Optional: Set credentials for remote connection
# Comment this block if using integrated authentication
$Username = '$($ServerConfig.CredUsername)'  # Optional
$Password = ConvertTo-SecureString '$($ServerConfig.CredPassword)' -AsPlainText -Force
$Credential = New-Object System.Management.Automation.PSCredential ($Username, $Password)

$failed = $false

foreach ($server in $servers) {
    try {
        Write-Host "Connecting to $server for health check..."

        $healthCheckResult = Invoke-Command -ComputerName $server -Credential $Credential -ScriptBlock {
            try {
                $url = "http://localhost/api/health"
                $resp = Invoke-WebRequest -Uri $url -UseBasicParsing -TimeoutSec 10 -ErrorAction Stop
                if ($resp.StatusCode -eq 200) {
                    Write-Host "Health check passed on $env:COMPUTERNAME"
                    return $true
                } else {
                    Write-Host "Health check failed with status: $($resp.StatusCode)"
                    return $false
                }
            } catch {
                Write-Host "Error checking health: $($_.Exception.Message)"
                return $false
            }
        }

        if (-not $healthCheckResult) {
            Write-Host "Health check failed on $server"
            $failed = $true
            break
        }
    } catch {
        Write-Host "Could not connect to $server: $($_.Exception.Message)"
        $failed = $true
        break
    }
}

if ($failed) {
    Write-Host "Initiating rollback..."

    $folders = Get-ChildItem -Path $DeploymentRoot -Directory |
        Where-Object { $_.Name -match '^\d+(\.\d+)*_\d{8}\.\d{6}$' } |
        Sort-Object {
            $timestamp = $_.Name.Split('_')[1]
            [datetime]::ParseExact($timestamp, 'ddMMyyyy.HHmmss', $null)
        } -Descending

    if ($folders.Count -gt 1) {
        $rollbackFolder = $folders[1].FullName
        Set-ItemProperty -Path "IIS:\Sites\$WebApplicationName" -Name physicalPath -Value $rollbackFolder
        Write-Host "Rolled back to: $rollbackFolder"
    } else {
        Write-Host "No rollback folder found."
    }
    exit 1
} else {
    Write-Host "All health checks passed. Proceeding..."
    exit 0
}
-----------------------------------------------------------------------------------------
